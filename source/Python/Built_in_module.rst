Основы синтаксиса
-----------------

Импорт модуля – относительно дорогостоящее мероприятие, поэтому Python предпри- нимает некоторые трюки
для ускорения этого процесса. Один из способов – создать байт-компилированные файлы (или байткод)
с расширением .pyc, которые являются некой промежуточной формой, в которую Python переводит программу
(помните раздел “Введение” о том, как работает Python?). Такой файл .pyc полезен при импорте модуля в
следующий раз в другую программу – это произойдёт намного быстрее, поскольку зна- чительная часть обработки,
требуемой при импорте модуля, будет уже проделана. Этот байткод также является платформо-независимым.

.. note::
    Обычно файлы .pyc создаются в том же каталоге, где расположены и соот- ветствующие им файлы .py.
    Если Python не может получить доступ для записи файлов в этот каталог, файлы .pyc созданы не будут.


Оператор from ... import ...
^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Чтобы импортировать переменную argv прямо в программу и не писать всякий раз sys. при обращении к ней,
можно воспользоваться выражением "from sys import argv".
Для импорта всех имён, использующихся в модуле sys, можно выполнить команду "from sys import """*"""".
Это работает для любых модулей.
В общем случае вам следует избегать использования этого оператора и использовать вместо этого оператор
import, чтобы предотвратить конфликты имён и не затруднять чтение программы.

.. code:: python

    from math import *
    n = input("Введите диапазон:- ") p = [2, 3]
    count = 2
    a=5
    while (count < n):
        b=0
        for i in range(2,a):
            if ( i <= sqrt(a)): if (a % i == 0):
                print("a neprost",a)
                b=1
            else:
                pass
        if (b != 1):
            print("a prost",a) p = p + [a]
        count = count + 1
        a=a+2
    print p


Имя модуля – __name__
^^^^^^^^^^^^^^^^^^^^^

У каждого модуля есть имя, и команды в модуле могут узнать имя их модуля. Это полез- но, когда нужно знать,
запущен ли модуль как самостоятельная программа или импорти- рован. Как уже упоминалось выше, когда модуль
импортируется впервые, содержащийся в нём код исполняется. Мы можем воспользоваться этим для того, чтобы
заставить мо- дуль вести себя по-разному в зависимости от того, используется ли он сам по себе или
импортируется в другую программа. Этого можно достичь с применением атрибута мо- дуля под названием __name__.

.. code:: python

    if __name__ == '__main__':
        print('Эта программа запущена сама по себе.')
    else:
        print('Меня импортировали в другой модуль.')

**Как это работает:**
    В каждом модуле Python определено его имя – __name__ . Если оно равно '__main__', это означает,
    что модуль запущен самостоятельно пользователем, и мы можем выполнить соответствующие действия.

Создание собственных модулей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Создать собственный модуль очень легко. Да вы всё время делали это! Ведь каждая про- грамма на Python
также является и модулем. Необходимо лишь убедиться, что у неё уста- новлено расширение .py.
Следующий пример объяснит это.


.. code:: python

    # mymodule.py

    def sayhi():
        print('Привет! Это говорит мой модуль.')
    __version__ = '0.1'

Выше приведён простой модуль. Как видно, в нём нет ничего особенного по сравнению с обычной программой
на Python. Далее посмотрим, как использовать этот модуль в дру- гих наших программах.
Помните, что модуль должен находиться либо в том же каталоге, что и программа, в ко- торую мы импортируем
его, либо в одном из каталогов, указанных в sys.path.

.. code:: python

    # mymodule_demo.py

    import mymodule

    mymodule.sayhi()
    print ('Версия', mymodule.__version__)


.. note::

    Обратите внимание, что мы используем всё то же обозначение точкой для до- ступа к элементам модуля.
    Python повсеместно использует одно и то же обо- значение точкой, придавая ему таким образом характерный
    «Python-овый» вид и не вынуждая нас изучать всё новые и новые способы делать что-либо.


Вот версия, использующая синтаксис from..import

.. code:: python

    # mymodule_demo2.py

    from mymodule import sayhi, __version__

    sayhi()
    print('Версия', __version__)

.. note::

    Обратите внимание, что если в модуле, импортирующем данный модуль, уже было объ- явлено имя __version__,
    возникнет конфликт. Это весьма вероятно, так как объявлять версию любого модуля при помощи этого имени –
    общепринятая практика. Поэтому всегда рекомендуется отдавать предпочтение оператору import, хотя это и
    сделает вашу программу немного длиннее.

Вы могли бы также использовать from mymodule import *

Это импортирует все публичные имена, такие как sayhi, но не импортирует __version__,
потому что оно начинается с двойного подчёркивания



Модули поставляемые с Python и Встроенные модули 
------------------------------------------------

Модули с _ в начале (например, _abc, _collections) — это внутренние низкоуровневые модули, которые Python использует сам, но их можно импортировать.
Остальные (например, math, sys, json, os) — обычные стандартные модули, доступные сразу без установки.
Публичный модуль (без _) — это “обёртка” над _модулем, которая делает интерфейс удобным, безопасным и переносимым между платформами.

Правило:
Используй публичные модули в своём коде.
_модули — только если знаешь точно, что делаешь, и нужен низкоуровневый доступ.


Модули, поставляемые с Python (stdlib .py modules)
--------------------------------------------------

Это пакеты и файлы Python, которые идут вместе с установкой Python.
Реализованы на Python (.py) и тоже доступны сразу после установки.
Примеры: os, json, re, collections, http.
Эти модули входят в sys.stdlib_module_names, вместе с встроенными.


.. code:: python

    # Просмотр всех модулей стандартной библиотеки
    import sys 
    print(sorted(sys.stdlib_module_names))

_модули
^^^^^^^^^^^^^^^

__future__
""""""""""""""""""""""""

_aix_support
""""""""""""""""""""""""

_android_support
""""""""""""""""""""""""

_apple_support
""""""""""""""""""""""""

_ast_unparse
""""""""""""""""""""""""

_asyncio
""""""""""""""""""""""""

_bz2
""""""""""""""""""""""""

_collections_abc
""""""""""""""""""""""""

_colorize
""""""""""""""""""""""""

_compat_pickle
""""""""""""""""""""""""

_ctypes
""""""""""""""""""""""""

_curses
""""""""""""""""""""""""

_curses_panel
""""""""""""""""""""""""

_dbm
""""""""""""""""""""""""

_decimal
""""""""""""""""""""""""

_elementtree
""""""""""""""""""""""""

_frozen_importlib
""""""""""""""""""""""""

_frozen_importlib_external
""""""""""""""""""""""""""

_gdbm
""""""""""""""""""""""""

_hashlib
""""""""""""""""""""""""

_ios_support
""""""""""""""""""""""""

_lzma
""""""""""""""""""""""""

_markupbase
""""""""""""""""""""""""

_multiprocessing
""""""""""""""""""""""""

_opcode_metadata
""""""""""""""""""""""""

_osx_support
""""""""""""""""""""""""

_overlapped
""""""""""""""""""""""""

_posixshmem
""""""""""""""""""""""""

_posixsubprocess
""""""""""""""""""""""""

_py_abc
""""""""""""""""""""""""

_py_warnings
""""""""""""""""""""""""

_pydatetime
""""""""""""""""""""""""

_pydecimal
""""""""""""""""""""""""

_pyio
""""""""""""""""""""""""

_pylong
""""""""""""""""""""""""

_pyrepl
""""""""""""""""""""""""

_queue
""""""""""""""""""""""""

_remote_debugging
""""""""""""""""""""""""

_scproxy
""""""""""""""""""""""""

_sitebuiltins
""""""""""""""""""""""""

_socket
""""""""""""""""""""""""

_sqlite3
""""""""""""""""""""""""

_ssl
""""""""""""""""""""""""

_strptime
""""""""""""""""""""""""

_threading_local
""""""""""""""""""""""""

_tkinter
""""""""""""""""""""""""

_uuid
""""""""""""""""""""""""

_weakrefset
""""""""""""""""""""""""

_wmi
""""""""""""""""""""""""

_zoneinfo
""""""""""""""""""""""""

_zstd
""""""""""""""""""""""""

abc
^^^^^^^^^^^^^^^^

annotationlib
^^^^^^^^^^^^^^^^

antigravity
^^^^^^^^^^^^^^^^

argparse
^^^^^^^^^^^^^^^^

ast
^^^^^^^^^^^^^^^^

asyncio
^^^^^^^^^^^^^^^^

base64
^^^^^^^^^^^^^^^^

bdb
^^^^^^^^^^^^^^^^

bisect
^^^^^^^^^^^^^^^^

bz2
^^^^^^^^^^^^^^^^

cProfile
^^^^^^^^^^^^^^^^

calendar
^^^^^^^^^^^^^^^^

cmd
^^^^^^^^^^^^^^^^

code
^^^^^^^^^^^^^^^^

codecs
^^^^^^^^^^^^^^^^

codeop
^^^^^^^^^^^^^^^^

collections
^^^^^^^^^^^^^^^^

colorsys
^^^^^^^^^^^^^^^^

compileall
^^^^^^^^^^^^^^^^

compression
^^^^^^^^^^^^^^^^

concurrent
^^^^^^^^^^^^^^^^

configparser
^^^^^^^^^^^^^^^^

contextlib
^^^^^^^^^^^^^^^^

contextvars
^^^^^^^^^^^^^^^^

copy
^^^^^^^^^^^^^^^^

copyreg
^^^^^^^^^^^^^^^^

csv
^^^^^^^^^^^^^^^^

Модуль csv позволяет легко:

читать CSV-файлы;
записывать данные построчно;
настраивать разделители, кавычки, кодировки;
работать с таблицами как со списками.

CSV = текстовый файл, где данные разделены символом (обычно , или ;).

Основные объекты:

csv.writer — запись строк;
csv.reader — чтение строк;
DictWriter / DictReader — запись/чтение как словарей.

.. code:: python

    import csv

    # --- Запись CSV ---
    with open('test.csv', 'w', encoding='utf-8') as csv_file:
            writer = csv.writer(csv_file, delimiter=';')
            # writer — объект для записи; delimiter=';' задаёт разделитель колонок
            writer.writerow(['user_id', 'user_name', 'comments_qty'])
            # writerow — записать одну строку (список → строка CSV)
            writer.writerow([5235, 'Mikhail', 1352])
            writer.writerow([1567, 'Olga', 246])
            writer.writerow([1990, 'Lina', 79])
            # Три строки с данными → попадут в test.csv

    # --- Чтение CSV ---
    with open('test.csv', encoding='utf-8') as csv_file:
        reader = csv.reader(csv_file)
        # reader — объект, который читает строки файла и превращает в списки
        for line in reader:
            print(line)
            # Каждая строка CSV возвращается как список (все значения — строки)

    # Пример с DictReader
    # Запись
    data = [
        {"user_id": 5235, "user_name": "Mikhail", "comments_qty": 1352},
        {"user_id": 1567, "user_name": "Olga", "comments_qty": 246},
    ]

    with open('dict.csv', 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=["user_id", "user_name", "comments_qty"])
        writer.writeheader()           # записывает заголовки
        writer.writerows(data)         # записывает список словарей

    # Чтение
    with open('dict.csv', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            print(row)
            # row — словарь

По умолчанию csv.writer использует: , как разделитель → мы переопределили на ; " как кавычки

Важные параметры:

delimiter	   Разделитель (;, ,, \t)
quotechar	   Кавычки для текстовых значений (обычно ")
quoting	       Когда ставить кавычки (csv.QUOTE_MINIMAL, ALL, NONE)
newline=''	   Обязательно на Windows, чтобы не было пустых строк

Когда CSV — идеальный выбор:
таблицы небольшого размера,
обмен данными между программами,
импорт/экспорт в Excel,
логи, статистика, выгрузки.

Когда CSV плохо подходит:
вложенные структуры (JSON лучше),
большие объёмы данных (>100MB),
бинарные данные,
сложные форматы.


ctypes
^^^^^^^^^^^^^^^^

curses
^^^^^^^^^^^^^^^^

dataclasses
^^^^^^^^^^^^^^^^

DateTime
^^^^^^^^^^^^^^^^

.. code:: python

    from datetime import data

    my_date = date(2100, 4, 15)
    print(my_date) # 2100-04-15
    print(my_date.day) # 15
    print(my_date.isocalendar()) # datetime.IsoCalendarDate(year=2100, week=15, weekday=4)

    from datetime import time
    my_time = time(18, 10, 45) # 18:10:45 час, минута, секунда
    print(my_time.hour) # 18

    from datetime import datetime
    my_datetime = datetime(2025, 12, 10, 18, 10, 45) # 2100-04-15 18:10:45

Форматирование дат

.. code:: python

    from datetime import datetime, timedelta

    my_datetime = datetime(2025, 12, 10, 18, 10, 45) # 2100-04-15 18:10:45
    my_datetime.strftime('%d-%b/%Y %H:%M:%S') # 10-Dec/2025 18:10:45
    a = '10/12/225'
    converted = datetime.strftime(a,'%d-%b/%Y %H:%M:%S') # 10-Dec/2025 18:10:45

    my_datetime + timedelta(days=100, hours=2) # прибавит к дате 100 дней

    import time
    time.time() # вывод секунд с Юникс эпохи с 01.01.1970
    time.ctime(24553453) # Mon Oct 12 15:24:13 1970
    time.sleep(2.5) # Остановит исполнение следующего кода на 2,5 секунд

    start_time = time.time()
    # выполняемый код
    end_time = time.time()
    print(end_time - start_time) # Время выполнения кода


dbm
^^^^^^^^^^^^^^^^

decimal
^^^^^^^^^^^^^^^^

difflib
^^^^^^^^^^^^^^^^

dis
^^^^^^^^^^^^^^^^

doctest
^^^^^^^^^^^^^^^^

email
^^^^^^^^^^^^^^^^

encodings
^^^^^^^^^^^^^^^^

ensurepip
^^^^^^^^^^^^^^^^

enum
^^^^^^^^^^^^^^^^

fcntl
^^^^^^^^^^^^^^^^

filecmp
^^^^^^^^^^^^^^^^

fileinput
^^^^^^^^^^^^^^^^

fnmatch
^^^^^^^^^^^^^^^^

fractions
^^^^^^^^^^^^^^^^

ftplib
^^^^^^^^^^^^^^^^

functools
^^^^^^^^^^^^^^^^

genericpath
^^^^^^^^^^^^^^^^

getopt
^^^^^^^^^^^^^^^^

getpass
^^^^^^^^^^^^^^^^

gettext
^^^^^^^^^^^^^^^^

glob
^^^^^^^^^^^^^^^^

graphlib
^^^^^^^^^^^^^^^^

grp
^^^^^^^^^^^^^^^^

gzip
^^^^^^^^^^^^^^^^

hashlib
^^^^^^^^^^^^^^^^

heapq
^^^^^^^^^^^^^^^^

hmac
^^^^^^^^^^^^^^^^

html
^^^^^^^^^^^^^^^^


http
^^^^^^^^^^^^^^^^

Протокол http – это простой текстовый протокол передачи данных.

Модуль http - это пакет, собирающий несколько модулей для работы с протоколом передачи гипертекста:

::

    *http.client* - низкоуровневый клиент протокола HTTP. Клиент высокого уровня urllib.request
    *http.server* - содержит базовые классы HTTP-серверов на основе socketserver
    *http.cookies* - имеет утилиты для реализации управления состоянием с помощью cookies
    *http.cookiejar* - обеспечивает сохраняемость cookies


Применяется модуль:

Обучение сетевому программированию (Отличный инструмент для понимания, как работает HTTP «под капотом».)

Создание простых REST-API (Без Flask/Django — идеально для экспериментов.)

Локальная разработка статических сайтов (http.server → просмотр HTML/CSS/JS как на сервере.)

Прототипирование (Можно быстро накидать мини-сервер для тестов.)

Системные утилиты (Обмен файлами в сети, просмотр каталогов, лёгкие админ-панели.)


http.client
""""""""""""""""

http.client — HTTP-клиент (аналог requests, но встроенный). Позволяет отправлять HTTP-запросы без сторонних библиотек.

Позволяет отправлять HTTP-запросы: GET, POST, PUT, DELETE, OPTIONS, …;  Работа по HTTP и HTTPS; Управление заголовками; Чтение тела ответа.
Не предназначен для использования в продакшн-среде. Его минимальные функции безопасности делают его легкой добычей для хакеров!

.. code:: python

    import http.client

    # Устанавливаем соединение с сервером
    conn = http.client.HTTPSConnection("www.python.org") # Можно использовать HTTPConnection для HTTP

    # Отправляем GET-запрос
    conn.request("GET", "/")

    # Получаем ответ
    response = conn.getresponse()
    print(f"Статус ответа: {response.status} {response.reason}") # Выведет 200 OK

    # Читаем тело ответа (декодируем байты в строку)
    data = response.read().decode('utf-8')
    # print(data) # Раскомментируйте, чтобы увидеть HTML-код страницы

    # Закрываем соединение
    conn.close()






http.server
""""""""""""""""

HTTPServer - Базовый класс сервера, принимает обработчик запросов.

.. code:: python

    python3 -m http.server 8000 # запустить HTTP-сервер. 8000 - порт

    python3 -m http.server --bind 127.0.0.1 8000 # Запуск локального сервера

    python3 -m http.server --directory /path/to/directory 8000 # доступ к файлам конкретной директории

    python3 -m http.server --bind ::1   # указывает, к какому IP-адресу сервер привязывается.
                                        # Запись ::1 сокращает длинный адрес: 0000:0000:0000:0000:0000:0000:0000:0001
                                        # http://[::1]:8000/

BaseHTTPRequestHandler - Базовый обработчик. Можно вручную описать методы: do_GET()  do_POST()  do_HEAD(). Позволяет строить свои API, обработчики форм, прокси и т.д.

SimpleHTTPRequestHandler - Готовый сервер статических файлов: отдаёт HTML, CSS, JS, изображения; поддерживает directory listing; опционально позволяет указать корневую директорию.

http.cookies
""""""""""""""""

http.cookies - Инструменты для создания и анализа HTTP-куки. (Основной класс — SimpleCookie)

Позволяет парсить cookie из заголовков; создавать Set-Cookie; работать со свойствами (max-age, path, secure). Используется в веб-фреймворках, в самописных серверных проектах.


http.cookiejar
""""""""""""""""



http.HTTPStatus
""""""""""""""""

http.HTTPStatus — перечисление HTTP-кодов

idlelib
^^^^^^^^^^^^^^^^

imaplib
^^^^^^^^^^^^^^^^

importlib
^^^^^^^^^^^^^^^^

inspect
^^^^^^^^^^^^^^^^

io
^^^^^^^^^^^^^^^^

ipaddress
^^^^^^^^^^^^^^^^

json
^^^^^^^^^^^^^^^^

keyword
^^^^^^^^^^^^^^^^

linecache
^^^^^^^^^^^^^^^^

locale
^^^^^^^^^^^^^^^^

logging
^^^^^^^^^^^^^^^^

lzma
^^^^^^^^^^^^^^^^

mailbox
^^^^^^^^^^^^^^^^

mimetypes
^^^^^^^^^^^^^^^^

modulefinder
^^^^^^^^^^^^^^^^

multiprocessing
^^^^^^^^^^^^^^^^

netrc
^^^^^^^^^^^^^^^^

ntpath
^^^^^^^^^^^^^^^^

nturl2path
^^^^^^^^^^^^^^^^

numbers
^^^^^^^^^^^^^^^^

opcode
^^^^^^^^^^^^^^^^

operator
^^^^^^^^^^^^^^^^

optparse
^^^^^^^^^^^^^^^^

os
^^^^^^^^^^^^^^^^

pathlib
^^^^^^^^^^^^^^^^

pdb
^^^^^^^^^^^^^^^^

pickle
^^^^^^^^^^^^^^^^

pickletools
^^^^^^^^^^^^^^^^

pkgutil
^^^^^^^^^^^^^^^^

platform
^^^^^^^^^^^^^^^^

plistlib
^^^^^^^^^^^^^^^^

poplib
^^^^^^^^^^^^^^^^

posix
^^^^^^^^^^^^^^^^

posixpath
^^^^^^^^^^^^^^^^

pprint
^^^^^^^^^^^^^^^^

profile
^^^^^^^^^^^^^^^^

pstats
^^^^^^^^^^^^^^^^

pty
^^^^^^^^^^^^^^^^

pwd
^^^^^^^^^^^^^^^^

py_compile
^^^^^^^^^^^^^^^^

pyclbr
^^^^^^^^^^^^^^^^

pydoc
^^^^^^^^^^^^^^^^

pydoc_data
^^^^^^^^^^^^^^^^

pyexpat
^^^^^^^^^^^^^^^^

queue
^^^^^^^^^^^^^^^^

quopri
^^^^^^^^^^^^^^^^

random
^^^^^^^^^^^^^^^^

re
^^^^^^^^^^^^^^^^

readline
^^^^^^^^^^^^^^^^

reprlib
^^^^^^^^^^^^^^^^

resource
^^^^^^^^^^^^^^^^

rlcompleter
^^^^^^^^^^^^^^^^

runpy
^^^^^^^^^^^^^^^^

sched
^^^^^^^^^^^^^^^^

secrets
^^^^^^^^^^^^^^^^

select
^^^^^^^^^^^^^^^^

selectors
^^^^^^^^^^^^^^^^

shelve
^^^^^^^^^^^^^^^^

shlex
^^^^^^^^^^^^^^^^

shutil
^^^^^^^^^^^^^^^^

signal
^^^^^^^^^^^^^^^^

site
^^^^^^^^^^^^^^^^

smtplib
^^^^^^^^^^^^^^^^

socket
^^^^^^^^^^^^^^^^

socket — низкоуровневый модуль

Сокет (socket) - конечная точка соединения: «IP + порт».

*Использовать socket нужно, когда:*
хочешь понять, как работают сети на низком уровне;
нужно создать свой протокол;
пишешь игры (UDP);
создаёшь чат, стриминг, перенос файлов (TCP);
работаешь с IoT, микроконтроллерами.

*Не использовать socket напрямую если нужно:*
веб-приложение → Flask / Django / FastAPI
запросы к API → requests / httpx
WebSocket → websockets / asyncio
готовый сервер → http.server

Протаколы:
TCP - Надёжный, гарантированная доставка, поток байтов (как телеграм в WhatsApp).
UDP - Быстрый, без гарантий (как бросать записки через окно).

socket — это базовый модуль Python для работы с сетевыми соединениями.

Он позволяет:
создавать сети клиент–сервер,
отправлять и принимать данные,
работать с TCP, UDP,
использовать IPv4 / IPv6,
строить свои протоколы поверх TCP/UDP.

Как работать с модулем socket (основные шаги)
Клиент (TCP):
Создать сокет
Подключиться к серверу
Отправить данные
Получить ответ
Закрыть сокет

.. code:: python

    # Простой клиент TCP
    import socket

    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # AF_INET — IPv4
    # SOCK_STREAM — TCP

    client.connect(("localhost", 5000))   # Подключение к серверу

    client.send(b"Hi server!")           # Отправляем bytes

    response = client.recv(1024)         # Получаем ответ
    print("Server:", response.decode())

    client.close()



Сервер (TCP):
Создать сокет
Привязать к IP/порту
Перевести в режим ожидания
Принять клиента
Получать/отправлять данные
Закрыть клиента

.. code:: python

    # Простой сервер TCP (пример)
    import socket

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # AF_INET — IPv4
    # SOCK_STREAM — TCP

    server.bind(("localhost", 5000))   # Привязываем IP + порт
    server.listen()                    # Начинаем слушать порт

    print("Server started...")

    conn, addr = server.accept()       # Ждём подключения
    print("Connected:", addr)

    data = conn.recv(1024)             # Получаем 1024 байта
    print("Client:", data.decode())

    conn.send(b"Hello from server")    # Отправляем ответ

    conn.close()                       # Закрыть соединение


UDP пример (быстрый, без соединения)

.. code:: python

    # UDP сервер
    import socket

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("localhost", 5001))

    while True:
        data, addr = sock.recvfrom(1024)
        print("Received:", data, "from", addr)
        sock.sendto(b"pong", addr)

    # UDP клиент
    import socket

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    sock.sendto(b"ping", ("localhost", 5001))
    data, _ = sock.recvfrom(1024)
    print(data)


Пример "Чат":



Сервер

Запуск сервера python server.py

.. code:: python

    import socket                                       
    # Подключаем модуль socket: предоставляет низкоуровневые примитивы для сетевого ввода-вывода (создание сокетов, привязка к IP/порту, прослушка и т.д.). Модуль реализует API ОС для работы с сетью.
    import threading                                    
    # Подключаем модуль threading: позволяет запускать отдельные потоки исполнения внутри одного процесса — используется, чтобы обслуживать каждого клиента параллельно, не блокируя основной цикл приёмов.

    clients = []                                        
    # Создаём пустой список clients: в него будут храниться объекты сокетов подключённых клиентов. Используется для рассылки сообщений всем клиентам и для управления активными соединениями.

    def handle_client(conn, addr):                      
        # Определяем функцию handle_client, принимающую два аргумента: conn — объект сокета, представляющий соединение с клиентом; addr — кортеж (IP, порт) клиента. Эта функция будет выполняться в отдельном потоке для каждого клиента.
        print(f"[+] Клиент подключён: {addr}")          
        # Печатаем в консоль информацию о подключении: адрес клиента. Это полезно для логирования и отладки.
        while True:                                     
            # Запускаем бесконечный цикл обработки сообщений от данного клиента. Цикл будет прерываться только при явном выходе (ошибка, закрытие соединения или пустой приём).
            try:
                msg = conn.recv(1024)                   
                # Вызываем метод recv на объекте сокета conn: блокирующий вызов, который ждёт входящих данных от клиента и читает до 1024 байт. Возвращаемый объект — байты (bytes). Если клиент корректно закрыл соединение, recv вернёт b''.
                if not msg:                             
                    # Проверяем: если msg пустой (b''), это означает, что клиент закрыл соединение со своей стороны (EOF).
                    break                               
                # Если клиент отключился, выходим из цикла обработки этого клиента, чтобы дальше корректно закрыть сокет и убрать его из списка.
            except Exception as e:                      
                # Ловим исключения при чтении (например, соединение сброшено, тайм-аут или другая сетевая ошибка).
                # Здесь мы явно перехватываем любые исключения, чтобы не падал поток; можно логировать e при необходимости.
                break                                   
            # При ошибке читаемого/сетевого характера также выходим из цикла — завершаем обслуживание данного клиента.

            broadcast(msg, conn)                        
            # Если получили сообщение (msg не пустой), вызываем функцию broadcast, передавая сообщение и сокет отправителя. broadcast разошлёт полученные байты всем остальным подключённым клиентам.

        conn.close()                                    
        # После выхода из цикла закрываем сокет клиента: освобождаем системный ресурс и уведомляем ОС, что соединение закончено.
        clients.remove(conn)                            
        # Удаляем объект сокета клиента из списка clients — больше не будем рассылать этому сокету сообщения и не будем пытаться с ним работать.
        print(f"[-] Клиент отключён: {addr}")           
        # Печатаем в лог информацию об отключении клиента — полезно для мониторинга и отладки.

    def broadcast(message, sender):                     
        # Определяем функцию broadcast, которая принимает message (байты) и sender — сокет отправителя. Её цель: отправить message всем подключённым клиентам, кроме отправителя.
        for client in clients:                          
            # Проходим по списку всех активных клиентских сокетов clients.
            if client != sender:                        
                # Пропускаем сокет отправителя, чтобы не отсылать сообщение обратно тому, кто его отправил (если нужно — можно убрать эту проверку).
                try:
                    client.send(message)                 
                    # Вызываем send на каждом клиентском сокете: отправляем те же байты message. send может отправить все байты или часть их; здесь используем простую модель (для небольших сообщений обычно отправляется полностью).
                except Exception:                       
                    # Если отправка не удалась (клиент разорвал соединение, сетевые ошибки), перехватываем исключение.
                    # В реальном приложении здесь желательно корректно обработать ошибку: закрыть сокет и удалить клиента из списка.
                    pass                                 
                # Для простоты пропускаем ошибку; в production это нужно фиксировать.

    def main():                                         
        # Определяем главную функцию main, которая запускает сервер, принимает подключения и создаёт потоки для каждого клиента.
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
        # Создаём новый сокет: AF_INET — адресная семья IPv4; SOCK_STREAM — потоковый сокет (TCP). Это объект низкоуровневого сокета ОС.
        server.bind(("localhost", 5000))                
        # Привязываем (bind) сокет к локальному IP и порту: "localhost" обычно резолвится в 127.0.0.1; порт 5000 — порт, на котором сервер будет принимать соединения. bind сообщает ОС, что этот процесс будет слушать указанный адрес/порт.
        server.listen()                                 
        # Переводим сокет в режим прослушивания входящих подключений. listen сообщает ОС, что сокет готов принимать подключающихся клиентов; приём очереди подключений по умолчанию (обычно system backlog).

        print("[*] Сервер запущен на порту 5000...")    
        # Выводим в консоль сообщение о старте сервера — чтобы пользователь видел, что сервер запущен и готов принимать соединения.

        while True:                                     
            # Главный цикл сервера — непрерывно ждём и принимаем новые подключения.
            conn, addr = server.accept()                
            # Метод accept блокирует выполнение до появления нового подключения. При подключении он возвращает кортеж: conn — новый сокет для общения с конкретным клиентом; addr — адрес клиента (IP, порт). Каждый клиент получает свой conn.
            clients.append(conn)                        
            # Добавляем новый сокет клиента в список clients — чтобы иметь возможность рассылать ему сообщения друг от друга.
            threading.Thread(target=handle_client, args=(conn, addr)).start()  
            # Создаём и запускаем новый поток исполнения: target — функция handle_client, args — её аргументы (conn, addr). .start() сразу запускает поток. Таким образом главный цикл остаётся неблокирующим и может принимать следующие подключения.

    if __name__ == "__main__":                         
        # Проверяем, что модуль запускается как основная программа (не импортируется как модуль другим скриптом). Эта конструкция предотвращает автоматический запуск main() при импорте.
        main()                                         
        # Вызываем main(): стартуем сервер.

Клиент

Запуск клиента (для каждого клиента требуется новый терминал) python client.py 

.. code:: python

    import socket  
    # Модуль для работы с сетевыми соединениями (TCP/UDP)
    import threading  
    # Модуль для работы с потоками, чтобы выполнять несколько задач одновременно

    def receive(sock):  
    # Функция для потока, который будет принимать сообщения от сервера
        """Поток для приёма сообщений от сервера"""
        while True:  
        # Бесконечный цикл, чтобы постоянно слушать сервер
            try:
                msg = sock.recv(1024).decode()  
                # Получаем до 1024 байт от сервера и декодируем в строку
                print(msg)  
                # Выводим полученное сообщение в консоль
            except:  
            # Если возникла ошибка при получении (например, сервер закрыл соединение)
                print("[!] Соединение потеряно")  
                # Сообщаем пользователю о потере соединения
                break  
                # Прерываем цикл, завершая поток

    def main():  
    # Основная функция программы
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
        # Создаём TCP сокет с IPv4
        client.connect(("localhost", 5000))  
        # Подключаемся к серверу на локальной машине, порт 5000
        print("Подключено к чату!")  
        # Сообщаем, что подключение успешно установлено

        # Создаём отдельный поток для функции receive, чтобы одновременно получать сообщения и писать свои
        threading.Thread(target=receive, args=(client,), daemon=True).start()  
        # target=receive — функция, которая будет выполняться в потоке
        # args=(client,) — передаём сокет в поток как аргумент
        # daemon=True — поток автоматически завершится при закрытии основной программы
        # start() — запускаем поток

        while True:  
        # Бесконечный цикл для отправки сообщений пользователем
            msg = input()  
            # Ждём ввода сообщения от пользователя
            client.send(msg.encode()) 
            # Кодируем сообщение в байты и отправляем серверу

    if __name__ == "__main__":  
    # Проверка: если файл запускается напрямую, а не импортируется
        main()  
        # Запускаем основную функцию программы


Основные методы сокета:
bind((host, port))	  Привязывает сокет к адресу (сервер)
listen(backlog)	      Начинает слушать входящие соединения (сервер)
accept()	          Принимает новое соединение (сервер)
connect((host, port)) Подключается к серверу (клиент)
send(data)	          Отправляет байты
recv(bufsize)	      Получает до bufsize байт
close()	              Закрывает сокет
settimeout(seconds)	  Устанавливает таймаут на операции с сокетом

всегда закрывай сокеты после использования (close()), иначе соединение может зависнуть.

Таймауты и блокирующий режим:
По умолчанию сокеты блокирующие, т.е. программа ждёт, пока операция завершится.
sock.settimeout(5) — задаёт таймаут 5 секунд. Если данные не придут — будет исключение socket.timeout.
Это важно, чтобы программа не «зависала» на recv() при обрыве соединения.

Работа с адресами:
gethostbyname('example.com') — переводит доменное имя в IP.
gethostname() — имя локальной машины.
Можно проверять адреса перед подключением.

Опции сокета (socket options):
setsockopt(level, optname, value) — управляет поведением сокета.
Примеры: SO_REUSEADDR (разрешает повторное использование порта), TCP_NODELAY (отключает Nagle для TCP).
На больших проектах важно для настройки производительности.

Работа с мультикастом, неблокирующим вводом, select/poll
Для более сложных сетевых приложений используют:
select.select() — проверяет готовность сокетов к чтению/записи
socket.setblocking(False) — делает сокет неблокирующим
Мультикаст/броадкаст через UDP
Эти вещи важны, если чат или сервер должны обслуживать десятки или сотни клиентов.

Ошибки и исключения
socket.error — базовое исключение для всех сетевых ошибок.
ConnectionResetError, TimeoutError — для обработки обрывов и таймаутов.
Важно: всегда оборачивать recv() и send() в try/except, чтобы программа не падала.

socketserver
^^^^^^^^^^^^^^^^

sqlite3
^^^^^^^^^^^^^^^^

sre_compile
^^^^^^^^^^^^^^^^

sre_constants
^^^^^^^^^^^^^^^^

sre_parse
^^^^^^^^^^^^^^^^

ssl
^^^^^^^^^^^^^^^^

stat
^^^^^^^^^^^^^^^^

statistics
^^^^^^^^^^^^^^^^

string
^^^^^^^^^^^^^^^^

stringprep
^^^^^^^^^^^^^^^^

struct
^^^^^^^^^^^^^^^^

subprocess
^^^^^^^^^^^^^^^^

symtable
^^^^^^^^^^^^^^^^

sysconfig
^^^^^^^^^^^^^^^^

syslog
^^^^^^^^^^^^^^^^

tabnanny
^^^^^^^^^^^^^^^^

tarfile
^^^^^^^^^^^^^^^^

tempfile
^^^^^^^^^^^^^^^^

termios
^^^^^^^^^^^^^^^^

textwrap
^^^^^^^^^^^^^^^^

this
^^^^^^^^^^^^^^^^

threading
^^^^^^^^^^^^^^^^

timeit
^^^^^^^^^^^^^^^^

tkinter
^^^^^^^^^^^^^^^^

token
^^^^^^^^^^^^^^^^

tokenize
^^^^^^^^^^^^^^^^

tomllib
^^^^^^^^^^^^^^^^

trace
^^^^^^^^^^^^^^^^

traceback
^^^^^^^^^^^^^^^^

tracemalloc
^^^^^^^^^^^^^^^^

tty
^^^^^^^^^^^^^^^^

turtle
^^^^^^^^^^^^^^^^

turtledemo
^^^^^^^^^^^^^^^^

types
^^^^^^^^^^^^^^^^

typing
^^^^^^^^^^^^^^^^

unicodedata
^^^^^^^^^^^^^^^^

unittest
^^^^^^^^^^^^^^^^

urllib
^^^^^^^^^^^^^^^^

uuid
^^^^^^^^^^^^^^^^

venv
^^^^^^^^^^^^^^^^

warnings
^^^^^^^^^^^^^^^^

wave
^^^^^^^^^^^^^^^^

weakref
^^^^^^^^^^^^^^^^

webbrowser
^^^^^^^^^^^^^^^^

winsound
^^^^^^^^^^^^^^^^

wsgiref
^^^^^^^^^^^^^^^^

xml
^^^^^^^^^^^^^^^^

xmlrpc
^^^^^^^^^^^^^^^^

zipapp
^^^^^^^^^^^^^^^^

ZipFile
^^^^^^^^^^^^^^^^

Zip

.. code:: python

    from zipfile import ZipFile
    from pathlib import Path

    Path('my-files').mkdir()
    with open('my-files/first.txt', 'w', encoding='utf-8') as my_file:
        my_file.write('Это первый файл')

    with open('my-files/second.txt', 'w', encoding='utf-8') as my_file:
        my_file.write('Это второй файл')

    with ZipFile('my-files/my-files.zip', mode='w') as my_zip_file:
        # print(my_zip_file) # <zipfile.ZipFile filename='my-files.zip' mode='w'>
        for file in Path('my-files').iterdir(): # iterdir() - метод итерация по директории
            print(file) # my-files\first.txt  # my-files\second.txt
            my_zip_file.write(file)

    with ZipFile('my-files/my-files.zip') as my_zip_file:
        my_zip_file.extractall('my-files-unzipped') # распаковка архива в новую папку my-files-unzipped
        print(my_zip_file.infolist()) # информация о каждом файле


zipimport
^^^^^^^^^^^^^^^^

zoneinfo
^^^^^^^^^^^^^^^^

Встроенные модули (built-in)
----------------------------

Они встроены в интерпретатор на этапе компиляции.
Реализованы на C (или другом низкоуровневом языке).
Не имеют .py файлов, работают сразу после запуска Python.
Примеры: sys, time, math, _thread, marshal.
Эти модули показываются в sys.builtin_module_names.

.. code:: python

    # Просмотр всех встроенных модулей
    import sys 
    print(sorted(sys.builtin_module_names))

_модули
^^^^^^^^^^^^^^^

_abc
""""""""""""""""""""""""
_ast'
""""""""""""""""""""""""

_bisect
""""""""""""""""""""""""

_blake2
""""""""""""""""""""""""

_codecs
""""""""""""""""""""""""

_codecs_cn
""""""""""""""""""""""""

_codecs_hk
""""""""""""""""""""""""

_codecs_iso2022
""""""""""""""""""""""""

_codecs_jp
""""""""""""""""""""""""

_codecs_kr
""""""""""""""""""""""""

_codecs_tw
""""""""""""""""""""""""

_collections
""""""""""""""""""""""""

_contextvars
""""""""""""""""""""""""

_csv
""""""""""""""""""""""""

_datetime
""""""""""""""""""""""""

_functools
""""""""""""""""""""""""

_heapq
""""""""""""""""""""""""

_hmac
""""""""""""""""""""""""

_imp
""""""""""""""""""""""""

_interpchannels
""""""""""""""""""""""""

_interpqueues
""""""""""""""""""""""""

_interpreters
""""""""""""""""""""""""

_io
""""""""""""""""""""""""

_json
""""""""""""""""""""""""

_locale
""""""""""""""""""""""""

_lsprof
""""""""""""""""""""""""

_md5
""""""""""""""""""""""""

_multibytecodec
""""""""""""""""""""""""

_opcode
""""""""""""""""""""""""

_operator
""""""""""""""""""""""""

_pickle
""""""""""""""""""""""""

_random
""""""""""""""""""""""""

_sha1
""""""""""""""""""""""""

_sha2
""""""""""""""""""""""""

_sha3
""""""""""""""""""""""""

_signal
""""""""""""""""""""""""

_sre
""""""""""""""""""""""""

_stat
""""""""""""""""""""""""

_statistics
""""""""""""""""""""""""

_string
""""""""""""""""""""""""

_struct
""""""""""""""""""""""""

_suggestions
""""""""""""""""""""""""

_symtable
""""""""""""""""""""""""

_sysconfig
""""""""""""""""""""""""

_thread
""""""""""""""""""""""""

_tokenize
""""""""""""""""""""""""

_tracemalloc
""""""""""""""""""""""""

_types
""""""""""""""""""""""""

_typing
""""""""""""""""""""""""

_warnings
""""""""""""""""""""""""

_weakref
""""""""""""""""""""""""

_winapi
""""""""""""""""""""""""

array
^^^^^

atexit
^^^^^^

binascii
^^^^^^^^

builtins
^^^^^^^^

cmath
^^^^^

errno
^^^^^

faulthandler
^^^^^^^^^^^^

gc
^^^

itertools
^^^^^^^^^

marshal
^^^^^^^

math
^^^^

mmap
^^^^

msvcrt
^^^^^^

nt
^^^

sys
^^^

time
^^^^

winreg
^^^^^^

xxsubtype
^^^^^^^^^

zlib
^^^^