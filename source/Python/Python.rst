******
Python
******

Описание
========

Для установки компилятора языка программирования скачайте инсталлятор
соответствующий ващей операционной ссистеме с сайта разработчика Python.org_

Так же установив Python можно использовать консольные утилиты

.. _Python.org: https://www.python.org/downloads/

Установка
=========

Windows
-------

.. code:: console

    choco install python3

Linux: Ubuntu
-------------

.. code:: sh

    sudo apt install python3

Linux: Fedora
-------------

.. code:: sh

    sudo dnf install python3


.. note::
    
    в Linux дистрибутивах установщик пакетов pip (он нам понадобится в будущем)
    необходимо устанавливать дополнительно.

    .. code:: sh

       sudo apt install python3-pip

Введение

Интерактивная среда IDLE
------------------------

Для вызова интерактивной среды разработчика достаточно в консоли набрать команду:

.. code:: sh

    python3


.. figure:: /_static/images/IDLE.png
    :figwidth: 600px
    :target: /_static/images/IDLE.png



В этой интерактивной среде можно выполнять команды Python и сразу же получать результат выполнение введенной команды.


Редакторы кода и среда разработки IDE
-------------------------------------

Для написания программ на языке Python подойдет любой текстовый редактор, но для более комфортной работы рекомендуется использовать
редакторы кода с подсветкой синтаксиса и отслеживанием ошибок. один из таких редакторов, это VSCODE_

Так же будет полезно использовать полноценную среду разработки IDE, одной из наиболее популярных евляется PyCharm_



Виртуальное окружение (venv)
----------------------------

Для начала работы рекомендуется подготовить виртуальное окружение, оно необходимо для того что бы вслучае использования
дополнительных библиотек они не конфликтовали с другими библиотеками используемыми в других проектах, например: нет
необходимости держать в одном проекте библиотеки фреймворков **Django** и **Flask**

Для того что бы создать виртуальное окружение, в папке с проектом необходимо выполнить команду:

.. code:: sh

    python -m venv venv

незабудьте так же активировать ваше виртуальное окружение выполнив команду:

.. code:: sh

    source venv/bin/activate

это создаст внутри проекта папку venv с компилятором и всеми необходимыми библиотеками используемые по умолчанию.

Так же для того что бы сохранить список используемых в нашем проекте библиотек, нужно создать файл reqirements.txt
его можно создать автоматически выполнив команду:

.. code:: sh

    pip freeze > requirements.txt


Для установки в наше виртуальное окружение необходимых библиотек нужно выполнить команду:

.. code:: sh

    pip install requirements.txt


Попробуйте установить фреймворк **flask** используя менеджер пакетов pip и сохраните список установленных пакетов:

.. code:: sh

    pip install flask
    pip freeze > requirements.txt


Теперь если вы откроете файл **requirements**
вы увидите список наших зависимостей используемые в нашем проекте

.. code:: python

    click==7.1.2
    Flask==1.1.2
    itsdangerous==1.1.0
    Jinja2==2.11.2
    MarkupSafe==1.1.1
    Werkzeug==1.0.1


Первая программа
----------------


Настало время написать нашу первую программу, создайте файл **Hello_World.py**
со следующим содержимым:

.. literalinclude:: ../../Examples/Hello_World.py
  :language: python


Теперь запустите нашу программу выполгив в консоле команнду:

.. code:: sh

    python Hello_World.py

в консои вы должны увидеть результат нашей программы.

.. note::

    Обратите внимание, что первая строка указывает какой интерпритатор мы будет использовать,
    она необходима если мы хотим запускать нашу команду с интерпритатором по умолчанию, например так:
    
    .. code:: sh

        ./Hello_World.py

    Если этой строки не будет, то мы получим ошибку.

    Вторая строка отвечает за кодировку, тоесть если мы хотим вывести на экран Русские символы, то нам надо
    указать какую кодировку мы будем ипользовать.

.. _PyCharm: https://www.jetbrains.com/pycharm/download/

.. _VSCODE: https://code.visualstudio.com












Основы синтаксиса
=================

Типы данных
-----------

Переменные в Python:
^^^^^^^^^^^^^^^^^^^^
Переменная в языке программирования это название для зарезервированного места в памяти компьютера,
предназначенное для хранения значений. Это означает, что когда вы создаете переменную, вы на самом деле резервируете
определенное место в памяти компьютера.
Основываясь на типе данных переменной, интерпретатор выделяет необходимое количество памяти и решает, что может
находится в зарезервированной области памяти.
Для понимания, можете думать о переменной как о коробке, в которую можно положить любую вещь, но только определенного
размера. Размер в данном примере будет типом переменной. Это не совсем верное определение, но оно дает общее представление о картине в целом.

**Основные форматы именования**

snake_case (змеиный регистр) - С маленькой буквы. Все буквы строчные. Слова разделяются символом подчёркивания _. (Используется в переменных, функциях, модулях, файлов)  
PascalCase (Паскаль-регистр) - Каждое слово начинается с заглавной буквы. Подчёркивания не используются. (Используется в классах, исключениях)  
SCREAMING_SNAKE_CASE (кричащий змеиный регистр) - все буквы заглавные, слова разделяются подчёркиваниями. (Используется для констант, БД)  
_single_leading_underscore (одиночное подчёркивание в начале) - подчёркивание в начале означает, что элемент внутренний. (Используется для приватных переменных, методов внутри модулей, классов.)  
__double_leading_underscore (двойное подчёркивание в начале) - Python изменяет имя внутри класса (name mangling), чтобы предотвратить случайное переопределение при наследовании (Используется для защиты атрибутов и методов от переопределения)  

Форматы в других  языках 
camelCase - верблюжий регистр
kebab-case - шашлычный стиль

**Полный список ключевых слов Python**

Все зарезервированные имена, которые нельзя использовать как переменные, функции или классы

::
    
    False       # Логическое значение False  
    True        # Логическое значение True  
    None        # Пустое значение / отсутствие значения  
    and         # Логическое "и"  
    or          # Логическое "или"  
    not         # Логическое "не"  
    is          # Проверка идентичности объектов  
    in          # Проверка принадлежности элемента последовательности  
    if          # Условный оператор  
    elif        # Иначе если  
    else        # Иначе  
    for         # Цикл for  
    while       # Цикл while  
    break       # Прерывание цикла  
    continue    # Продолжение цикла  
    def         # Определение функции  
    return      # Возврат значения из функции  
    class       # Определение класса  
    try         # Начало блока try-except  
    except      # Обработка исключений  
    finally     # Завершение блока try-except  
    raise       # Генерация исключения  
    import      # Подключение модуля  
    from        # Импорт конкретного элемента из модуля  
    as          # Псевдоним при импорте  
    with        # Контекстный менеджер  
    lambda      # Анонимная функция  
    pass        # Пустая операция  
    yield       # Возврат значения генератором  
    global      # Глобальная переменная  
    nonlocal    # Область видимости не локальная  
    assert      # Проверка условия  
    del         # Удаление объекта  

Как проверить в Python актуальные ключевые слова

.. code:: python

    import keyword
    print(keyword.kwlist)

Python чувствителен к регистру, поэтому Var, var и VAR — разные имена.

Нельзя использовать для своих переменных или функций:
пробелы, дефисы -, специальные символы (@, !, %, $ и т.д.)

.. code:: python

    __init__      # Конструктор класса
    __str__       # Представление объекта как строки
    1variable = 5 # Нельзя начинать имя с цифры
    
    # не рекомендуется переопределять встроенные функции и типы Python
    list = [1, 2, 3]        # перезапишет встроенный list
    str = "Hello"           # перезапишет встроенный str
    id = 100                # перезапишет встроенный id()

**Присвоение значения переменной:**

В Python вам не нужно объявлять тип переменной вручную (как, например в С++). Объявление происходит автоматически
(это называется динамическая типизация), когда вы присваиваете значение переменной. Знак равенства ( = ) используется
для присвоения значения переменной.
Операнд по левую сторону от знака равно ( = ) это имя переменной, операнд по правую сторону - значение присвоенное
этой переменной.

.. code:: python

    # Простое присваивание
    x = 10        # число
    y = "hello"   # строка
    z = [1, 2, 3] # список

    # Множественное присваивание
    a, b, c = 1, 2, 3

    # Распаковывается в несколько переменных.
    data = [10, 20, 30, 40]
    x, y, *rest = data # x - 10, y - 20, rest - 30,40  Можно использовать * в любом месте, но только один раз.

    # Упаковка в кортеж
    t = (x, y, *rest)
    
    # Обмен значений
    a = 1
    b = 2
    a, b = b, a
    print(a, b)  # 2 1

    # Распаковка с _ для игнорируемых значений
    a, _, b = [1, 2, 3]
    print(a, b)  # 1 3




**Таблица - Обзор встроенных типов объектов**

+------------------------------+---------+-----------------------------------------------+
| Имя                          | Тип     |  Описание  и пример                           |
+==============================+=========+===============================================+
| Целые Числа                  | int     |  Целые положительные или отрицательные числа  |
|                              |         |  -35, 0, 24, 123467890033373747428            |
+------------------------------+---------+-----------------------------------------------+
| Числа с плавающей точкой     | float   |  Дробные числа 3.14, 2.5, -2.33333, 0.12334   |
+------------------------------+---------+-----------------------------------------------+
|  Строки                      | str     |  Строки "asdf", "Hello world", "123456"       |
+------------------------------+---------+-----------------------------------------------+
| Списки                       | list    |  последовательность элементов                 |
|                              |         |  ["hello", -123, 0.34, "345"]                 |
+------------------------------+---------+-----------------------------------------------+
| Словарь                      | dict    |  Последовательность пар элементов содержаших  |
|                              |         |  ключ-значение (key-value)                    |
|                              |         |  {"Language": "Python", "Version": "3.8"}     |
+------------------------------+---------+-----------------------------------------------+
| Кортеж (Tuple)               | tup     |  Неизменяемая упорядоченная последовательность|
|                              |         |  элементов ("hostname", 1234, -0.45, -32)     |
+------------------------------+---------+-----------------------------------------------+
| Множество                    | set     |  Изменяемая неупоряоченная последовательность |
|                              |         |  элементов {10, "Name", -30, 4.02, 100}       |
+------------------------------+---------+-----------------------------------------------+
| Булевые значения             | bool    |  Тип данных принимающий одно из двух значений |
|                              |         |  true - истина                                |
|                              |         |  false - ложь                                 |
+------------------------------+---------+-----------------------------------------------+


Числа, округление, системы счисления
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Числа - Это не изменяемый тип данных.  
Числа в Python бывают трёх типов: целые, с плавающей точкой и комплексные.  
Примером целого числа может служить 2.  
Примерами чисел с плавающей точкой (или «плавающих» для краткости) могут быть 3.23 и 52.3E-4. Обозначение E показывает степени числа 10. В данном случае 52.3E-4 означает 52.3 · 10−4.  
Примеры комплексных чисел:(-5+4j)и(2.3-4.6j)  

.. note::

    Нет отдельного типа ‘long int’ (длинное целое). Целые числа по умолчанию могут быть произвольной длины.


Округление
""""""""""

.. code:: python

    round(2.3) # округляет число до ближайшего целого числа, и если дробная часть числа
            # меньше 0.5, то число округляется вниз. Таким образом, round(2.3) будет равно 2, а не 3.
    int(2.3+ 0.5) #  всегда округляет число вниз, также будет равно 2

    import math
    num = 2.3
    rounded_num = math.ceil(num)
    print(rounded_num)  # выводит: 3

    round(number[, ndigits]) # округляет число number до ndigits знаков после запятой (по умолчанию, 
                             # до нуля знаков, то есть, до ближайшего целого) Здесь используется так 
                             # называемое "Банковское округление", то есть округление к ближайшему 
                             # чётному.

Системы счисления
""""""""""""""""""

.. code:: python

    # двоичная система
    number = 10  # Пример числа
    binary_representation = bin(number)
    print(binary_representation)     # Выводит '0b1010'
                                     # 0b является префиксом, обозначающим, что последующие цифры находятся в двоичной системе.
                                     # 0o это префикс числа, означающий восьмеричную систему счисления. 
                                     # 0x этот префикс используется для шестнадцатеричных 
    print(binary_representation[2:]) # Выводит '1010'

    # В восьмеричной
    decimal_number = 64
    octal_representation = oct(decimal_number)  # Возвращает '0o100'

    # В шестнадцатеричной 
    decimal_number = 255
    hexadecimal_representation = hex(decimal_number)  # Возвращает '0xff'
    
                        # A (или a) представляет число 10.
                        # B (или b) представляет число 11.
                        # C (или c) представляет число 12.
                        # D (или d) представляет число 13.
                        # E (или e) представляет число 14.
                        # F (или f) представляет число 15.
    binary_number = '101'                   # или '0b101'
    decimal_number = int(binary_number, 2)  # Второй параметр это 2 - двоичная, 8 - восьмеричная,  16 - шестнадцатеричная
    print(decimal_number)                   # Выведет 5
    print(1_000_000_000)                    # Выведет 1000000000

Строки, форматирование
^^^^^^^^^^^^^^^^^^^^^^

Строки - это неизменяемая упорядоченная последовательность символов, заключенная в кавычки.  
Строки применяются для записи текстовой информации (скажем, вашего имени) и произвольных совокупностей байтов  
(наподобие содержимого файла изображения). Они являются первым примером того, что в Python называется  
последовательностью — позиционно упорядоченной коллекцией других объектов. Для содержащихся элементов  
последовательности поддерживают порядок слева направо: элементы сохраняются и извлекаются по своим относительным позициям.  
Строго говоря, строки представляют собой последовательности односимвольных строк.  

Строки можно суммировать. Тогда они объединяются в одну строку, такая операция называется "Конкатенацией строк":

.. code:: python

    firts_string = "asdfgh"
    second_string = "oiuytr"
    print(firts_string + second_string)


.. note::

    В Python 3 нет ASCII-строк, потому что Unicode является надмножеством (включает в себя) ASCII. Если необходимо получить
    строку строго в кодировке ASCII, используйте str.encode("ascii"). По умолчанию все строки в Unicode.

.. warning::

    Нельзя производить арифметические операции над строкам и числами
    Например:
    "qwerty" + 3
    Это вызовет ошибку, Но строки можно перемножать
    "#" * 10
    выведет на экран строку
    ##########

Логические и физические строки
""""""""""""""""""""""""""""""

Физическая строка – это то, что вы видите, когда набираете программу.     
Логическая строка – Логическая строка составляется из одной или нескольких физических строк.
это то, что Python видит как единое предложение.    

Комментарии - начинается символом '#', не являющимся частью строкового литерала

`;` - объединяет две логических строки в одну физическую

.. code:: python
    
    # Две логических, физических строчек
    i=5 
    print(i)

    # Две логических строки на одной физической строке
    i = 5; print(i);

Рекомендовано придерживаться написания одной логической строки в каждой физической строке. 
Использовать разделение логической строки лишь в случае очень длинных строк. 

``\`` - разделяет логическую стоку на две физических

.. code:: python

    # Явное объединением строк.
    s = 'Это строка. \
    Это строка продолжается.' #Это строка. Это строка продолжается.
    print(s) #Это вторая логическая строка
    
    month_names = ['Январь',   'февраль', # Физическая строка  
                  'Март',     'Апрель']   # Физическая строка
    # month_names = ['Январь',   'февраль', 'Март', 'Апрель'] - одна логическая строка


Управление выводом и спецсимволы
""""""""""""""""""""""""""""""""

**Спецсимволы (Escape-последовательности)**

.. code:: python

    # \n - перенос строки (newline)
    print("Привет\nМир")  # Привет
                          # Мир
    # \t - Табуляция (отступ)
    print("A\tB") # A B

    # \r - Возврат каретки (начало строки)
    print("123\rA") # A23

    # \\ - Сам символ обратного слэша
    print("C:\\Python") # C:\Python

    # \' - Одинарная кавычка
    print('It\'s OK') # It's OK

    # \" - Двойная кавычка
    print("Он сказал: \"Привет!\"") # Он сказал: "Привет!"

    # \b - Backspace (удаляет предыдущий символ)
    print("ABC\bD") # ABD

    # \u - Юникод-символ (по коду)
    print('\u2764') # ❤️

**Аргументы функции print()**

.. code:: python

    # sep - Разделитель между элементами
    print('A','B','C', sep='-') # A-B-C

    # end - Что добавляется в конце строки
    print('Hello', end='!') # Hello!

    # file - Куда выводить текст (например, в файл)
    print('Текст', file=open('out.txt','w')) # запись в файл

    # flush - Немедленно записать вывод (не ждать буфера)
    print('...', flush=True) 

Операции над последовательностями
"""""""""""""""""""""""""""""""""

Проверить длину с помощью встроенной функции **len()**
Нумерация всех символов в строке идет с нуля 0 1 2 3 4 5.
Индекс  simple_string **[1]**

.. code:: python

    simple_string = 'Spam'
    len(simple_string)
    # 4 (подсчитывает количество символов)
    simple_string[0]
    # 'S'
    simple_string[1]
    # 'p'

Если нужно обратиться к какому-то по счету символу, начиная с конца,
то можно указывать отрицательные значения (на этот раз с единицы).

.. code:: python

    simple_string = "StringBody"
    simple_string[1]
    # t

    simple_string[-1]
    # y

Кроме обращения к конкретному символу, можно делать срезы строк, указав диапазон номеров (срез выполняется по второе число, не включая его):

.. code:: python

    example_string = "Lorem Ipsum is simply dummy text of the printing and typesetting"
    example_string[0:9]
    # 'Lorem Ips'

    example_string[10:22]
    # 'm is simply '

    # Если не указывается второе число, то срез будет до конца строки:
    example_string[-3:]
    # 'ing'

Также в срезе можно указывать шаг:

.. code:: python

    # Так можно получить нечетные числа
    a = '0123456789'
    a[1::2]
    # '13579'

    # А таким образом можно получить все четные числа строки a:
    a[::2]
    # '02468'

    # Срезы также можно использовать для получения строки в обратном порядке:
    a[::-1]
    # '9876543210'

Методы для работы со строками
"""""""""""""""""""""""""""""

**Методы upper, lower, swapcase, capitalize**

Методы выполняют преобразование регистра строки:

.. code:: python

    string1 = 'FastEthernet'

    string1.upper()     #'FASTETHERNET'
    string1.lower()     #'fastethernet'
    string1.swapcase()  #'fASTeTHERNET'

    string2 = 'tunnel 0'
    string2.capitalize() #'Tunnel 0'

    # Очень важно обращать внимание на то, что часто методы возвращают преобразованную строку  
    # и значит, надо не забыть присвоить ее какой-то переменной (можно той же).
    string1 = string1.upper()
    print(string1)      #FASTETHERNET

**Метод count**

Метод используется подсчета, сколько раз символ или подстрока встречаются в строке:

.. code:: python

    string1 = 'Hello, hello, hello, hello'
    string1.count('hello')  # 3
    string1.count('ello')   # 4
    string1.count('l')      # 8

**Метод find**

Методу можно передать подстроку или символ, и он покажет, на какой позиции находится первый   
символ подстроки (для первого совпадения):

.. code:: python

    string1 = 'interface FastEthernet0/1'

    string1.find('Fast')            # 10
    string1[string1.find('Fast')::] # 'FastEthernet0/1'

**Методы startswith, endswith**

Проверка, начинается или заканчивается ли строка на определенные символы:

.. code:: python

    string1 = 'FastEthernet0/1'

    string1.startswith('Fast')  # True
    string1.startswith('fast')  # False
    string1.endswith('0/1')     # True
    string1.endswith('0/2')     # False

**Метод replace**

Замена последовательности символов в строке на другую последовательность:

.. code:: python

    string1 = 'FastEthernet0/1'

    string1.replace('Fast', 'Gigabit') # 'GigabitEthernet0/1'

**Метод strip**

Часто при обработке файла файл открывается построчно. Но в конце каждой строки или в начале , как правило,  
есть какие-то спецсимволы, например, перевод строки.
По умолчанию метод strip() убирает пробельные символы. В этот набор символов входят: \t\n\r\f\v

.. code:: python

    string1 = '\n\tinterface FastEthernet0/1\n'
    
    print(string1)        # (перевод строки \n)
                          #interface FastEthernet0/1
                          # (перевод строки \n)
    string1.strip()       #'interface FastEthernet0/1' - удаляет спецсимволы в начале и в конце строки

    "   hello   ".strip() # 'hello'

.. code:: python

    #Методу strip можно передать как аргумент любые символы
    "---hello***".strip("-*")  # 'hello'

    lstrip() удаление символов с лева
    rstrip() удаление символов с права

**Метод split**

Метод разбивает строку на части, используя как разделитель какой-то символ (или символы) и возвращает список строк:

.. code:: python

    string1 = 'switchport trunk allowed vlan 10,20,30,100-200'
    commands = string1.split()
    print(commands) # ['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']

    # По умолчанию в качестве разделителя используются пробельные символы (пробелы, табы, перевод строки), 
    # но в скобках можно указать любой разделитель:
    vlans = commands[-1].split(',')
    print(vlans) #['10', '20', '30', '100-200']

**Метод join**

Метод позволяет объединить список, кортеж или словарь в строку разделяя ее элементы другой строкой.

.. code:: python

    myTuple = ("John", "Peter", "Vicky")
    x = "-".join(myTuple)
    print(x) #John-Peter-Vicky

**Метод format**

Метод позволяет подставлять в отмеченные в строке области символами "{}" значения из списка аргументов

например:

.. code:: python

    price = 49
    txt = "The price is {} dollars"
    print(txt.format(price))

Так же можно указать тип подставляемых значений:

.. code:: python

    #Строковые значения
    '{} {}'.format('one', 'two') # Подставляет строки по порядку: 'one two'

    #Числовые значения
    '{} {}'.format(1, 2) # Подставляет числа по порядку: '1 2'

    #Порядок значений можно указывать
    '{1} {0}'.format('one', 'two') # Подставляет второй аргумент первым и первый вторым: 'two one'

    #Можно так же подставлять значения классов
    class Data(object):

        def __str__(self):
            return 'str'  # Возвращает «читаемое» строковое представление объекта

        def __repr__(self):
            return 'repr' # Возвращает «официальное» представление объекта

    '{0!s} {0!r}'.format(Data()) # !s вызывает __str__, !r вызывает __repr__: 'str repr'

    # Отступы и выравнивания

    # По правому краю, ширина 10
    '{:>10}'.format('test') # '      test' (6 пробелов + 'test')

    # По левому краю, ширина 10, заполняется '_'
    '{:_<10}'.format('test') # 'test______'

    # По центру, ширина 10
    '{:^10}'.format('test') # '   test   ' (по 3 пробела слева и справа)

    # Срезы строк
    '{:.5}'.format('xylophone') # 'xylop' (берем первые 5 символов)

    # Срезы и отступы одновременно
    '{:10.5}'.format('xylophone') # 'xylop     ' (срез до 5 символов + выравнивание по левому краю до ширины 10)

    # Числа
    '{:d}'.format(42) # '42' (целое число)
    '{:f}'.format(3.141592653589793) # '3.141593' (число с плавающей точкой, 6 знаков после запятой по умолчанию)

    # Числа и отступы
    '{:4d}'.format(42) # '  42' (ширина 4, добавлены пробелы слева)
    '{:06.2f}'.format(3.141592653589793) # '003.14' (ширина 6, 2 знака после запятой, заполняем нулями)
    '{:04d}'.format(42) # '0042' (ширина 4, заполняем нулями)

    # Знаковые числа
    '{:+d}'.format(42)  # '+42' (показываем знак числа)
    '{: d}'.format(-23)  # '-23' (отступ перед положительным числом не нужен, знак сохраняется для отрицательного)
    '{: d}'.format(42)   # ' 42' (пробел перед положительным числом)
    '{:=5d}'.format(-23)  # '-  23' (минус слева, числа справа, ширина 5)
    '{:=+5d}'.format(23)  # '+  23' (плюс слева, числа справа, ширина 5)

    # Можно вставлять значения по именам
    data = {'first': 'Hodor', 'last': 'Hodor!'}
    '{first} {last}'.format(**data)  # 'Hodor Hodor!' (распаковка словаря по ключам)
    '{first} {last}'.format(first='Hodor', last='Hodor!')  # 'Hodor Hodor!' (явное именование аргументов)

    # Формат даты и времени
    from datetime import datetime
    '{:%Y-%m-%d %H:%M}'.format(datetime(2001, 2, 3, 4, 5))  # '2001-02-03 04:05' (форматирование даты и времени)

другие примеры форматированного вывода можно найти по следующим ссылкам pyformat.info_ w3schools.com_

Преобразования и Форматирование:

.. code:: python

    capitalize(): #Преобразует первый символ в верхний регистр.
    casefold():   #Преобразует строку к нижнему регистру для нечувствительного к регистру сравнения.
    lower():      #Преобразует все символы в нижний регистр.
    upper():      #Преобразует все символы в верхний регистр. if i.upper() - возвращают преобразованную строку, а не булево значение.
    title():      #Преобразует первый символ каждого слова в верхний регистр.
    swapcase():   #Меняет регистр каждого символа на противоположный.
    format():     #Форматирует строку. f'{} текс'
    format_map(): #Форматирует строку, используя словарь.

Обрезка и Выравнивание:

.. code:: python

    strip():  #Удаляет пробелы в начале и в конце строки.
    rstrip(): #Удаляет пробелы в конце строки.
    lstrip(): #Удаляет пробелы в начале строки.
    center(): #Выравнивает строку по центру.
    ljust():  #Выравнивает строку по левому краю.
    rjust():  #Выравнивает строку по правому краю.
    zfill():  #Дополняет строку нулями слева до указанной длины.

Поиск и Замена:

.. code:: python

    count():      #Считает количество вхождений подстроки.
    endswith():   #Проверяет, заканчивается ли строка указанной подстрокой.
    startswith(): #Проверяет, начинается ли строка с указанной подстроки.
    find():       #Находит первое вхождение подстроки. Если строка не найдена, метод вернет -1.
    rfind():      #Находит последнее вхождение подстроки.
    index():      #Похож на find, но вызывает ошибку, если подстрока не найдена.
    rindex():     #Похож на rfind, но вызывает ошибку, если подстрока не найдена.
    replace():    #Заменяет одну подстроку на другую.

Разделение и Объединение:

.. code:: python

    split():      #Разделяет строку на список строк по разделителю.
    rsplit():     #Разделяет строку на список строк по разделителю справа налево.
    splitlines(): #Разделяет строку на список строк по символам новой строки.
    join():       #Объединяет коллекцию строк в одну строку с разделителем.
    partition():  #Разбивает строку на три части по разделителю.
    rpartition(): #Разбивает строку на три части по разделителю справа налево.

Проверки и Валидация:

.. code:: python

    isalnum():      #Проверяет, состоит ли строка только из буквенно-цифровых символов.
    isalpha():      #Проверяет, состоит ли строка только из букв.
    isdigit():      #Проверяет, состоит ли строка только из цифр.
    isdecimal():    #Проверяет, состоит ли строка только из десятичных цифр.
    isnumeric():    #Проверяет, состоит ли строка только из числовых символов.
    isidentifier(): #Проверяет, является ли строка допустимым идентификатором.
    isspace():      #Проверяет, состоит ли строка только из пробельных символов.
    islower():      #Проверяет, написана ли строка в нижнем регистре.
    isupper():      #Проверяет, написана ли строка в верхнем регистре.
    istitle():      #Проверяет, написана ли строка в виде заголовка.
    isprintable():  #Проверяет, состоит ли строка только из печатаемых символов.
    isascii():      #Проверяет, состоят ли все символы строки из ASCII.

Прочие:

.. code:: python

    encode():              #Кодирует строку в указанной кодировке.
    expandtabs(tabsize=8): #Заменяет символы табуляции на пробелы.
    translate():           #Выполняет замену символов в строке на основе заданной таблицы замен.


.. _pyformat.info: https://pyformat.info

.. _w3schools.com: https://www.w3schools.com/python/python_string_formatting.asp

**Интернирование**

Это процесс, при котором одна и та же строка хранится в памяти только в одном экземпляре, 
чтобы избежать излишнего расхода памяти, особенно когда строки повторяются или часто 
используются в коде.

Это сделано для того, чтобы сэкономить память и оптимизировать производительность. Если строки используются часто и они 
короткие, то нет смысла держать несколько одинаковых объектов в памяти.

.. code:: python

    # Если одинаковые строки имеет меньше 5 символов то они ссылаются на одну ячейку памяти
    # Если больше 20 то создаются две ячейки памяти 

    a = 'Стр'
    b = 'Стр'
    print(a is b) #True

    a = 'Строка которая имеет более 20 символов ASCII'
    b = 'Строка которая имеет более 20 символов ASCII'
    print(a is b) #False  

НЕ интернирована (динамическая строка) 

.. code:: python

    a = 'Стр'+'ока' # динамическая строка

.. code:: python

    print(r'C:\some\name') # C:\some\name  -  r убирает экранирование
    print('some\name')     # some 
                           # ame
    rew2 = ('два' 
            '666')
    print(rew2) # два666  - объединяет две строчки рядом стоящие


T-строки
""""""""





Списки
^^^^^^
Списки – это изменяемые упорядоченные последовательности произвольных объектов. 
Списки создаются посредством заключения элементов списка в квадратные скобки. 
Списки могут содержать объекты любого типа, числа, строки, другие списки

.. code-block:: python

    names = [1,"Dave",3.14, ["Mark", 7, 9, [100,101]], 10]  # разные типы данных.

Элементы списка индексируются целыми числами, первый элемент списка имеет индекс, равный нулю.
Для доступа к отдельным элементам списка используется оператор индексирования

.. code-block:: python

    a = names[2] # Вернет третий элемент списка, "Ann"
    names[0] = "Jeff" # Запишет имя "Jeff" в первый элемент списка

.. code:: python

    my_list = ['Список', 2, True]  # разные типы данных.
    my_list2 = [True, 2, 'Список'] 

    print(my_list == my_list2)     # Возвращает False так как очередность важна.

    my = []    # Будет ровняться False

    my2 = [    # при передачи данных с сервера ил на сервер
        {
          'us_id': 123
          'us_nm': 'Red'
        },
        {
          'us_id': 65
          'us_nm': 'Green'
        }    
    ]

    sp = my_list + my_list2 # Объединяет списки


Индексы и срезы:
С помощью оператора среза ":" можно извлекать и изменять целые фрагменты списков:

.. code:: python

    my_list = ['Список', 2, True]

    my_list[1] = 3         # Перезапись значения индекса 1
    del my_list[0]         # Удалит элемент списка

    print(my2[0]['us_id']) # выведет значение по ключу когда в списке словарь

    my_list[0]             # Выведет 'Список' 
    my_list[-1]            # Выведет True

    s = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    r = s[:2]      # 1, 2
    r = s[1:-1]    # 2, 3, 4, 5, 6, 7, 8, 9
    r = s[-2:]     # 8, 9

    example_string = "Lorem Ipsum typesetting"
    example_string[0:9]
    # 'Lorem Ips'

    example_string[-3:]
    # 'ing' -1 это последний элемент

    # Так можно получить нечетные числа
    a = '0123456789'
    a[1::2]
    # '13579'

    # А таким образом можно получить все четные числа строки a:
    a[::2]
    # '02468'

    # Срезы также можно использовать для получения строки в обратном порядке:
    a[::-1]
    # '9876543210'

    rew2 = "Привет бандит"
    print(rew2[50:70])
    #   - вернет пустоту

    rew2 = "Привет бандит"
    print(rew2[3:70])
    #  вет бандит
    
    [1,2,3] + [4,5] # Создаст список [1,2,3,4,5]


Методы для работы со списками
"""""""""""""""""""""""""""""

.. code:: python

    l = list()              # создаст пустой список
    s = list('1234567890')  # [1,2,3,4,5,6,7,8,9] 
    s.append(10)            # Добавляет элемент в конец списка
    s.insert(2, 8)          # Вставляет объект перед индексом. Аргумент №1 = индекс, №2 - значение
    s.clear()               # Очищает список
    s.reverse()             # Переворачивает список
    s.pop(0)                # Удаляет элемент, если нет аргумента pop() удалит последний элемент
    s.pop(0)                # Удаляет последний элемент
    elem = s.pop(0)         # Возвращает при удалении элемента
    s.sort()                # Сортирует по возрастанию
    s.sort(reverse = True)  # Сортирует по убыванию
    s.copy()                # Копирует список
    s.count(5)              # Выведет сколько раз встречается этот элемент в списке
    s.remove("2")           # Удаляет указанный элемент и не возвращает удаленный элемент
    s.index()               # Возвращает позицию первого вхождения элемента
    s.extend('abcd')        # Расширение списка [1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd']
    s.extend(l)             # Объединить два списка

Конвертация:

.. code:: python

    s = 'Конвертирует строку в список'
    sl = list(s) #  ['К', 'о', 'н', 'в', 'е', 'р', 'т', 'и', 'р', 'у', 'е', 'т', ' ', 'в', ' ',
                 #   'с', 'т', 'р', 'о', 'к', 'у', ' ','в' , ' ', 'с', 'п', 'и', 'с', 'о', 'к']

    sl = {'a': 10, 'f': True} # Преобразование словаря в список
    slk = list(sl)  # ['a', 'f']

    a = ['10', '20', '30']
    print(','.join(a)) # 10,20,30


Арифметические операции:

.. code:: python

    s = [1, 2, 3, 4, 5, 6]
    min(s)  # 1
    max(s)  # 6
    sum(s)  # 21
    sum(s) / len(s) # 3.5 среднее значение в списке

Копирование:

.. code:: python

    s = [1, 2, 3, 4]
    r = s  # не копирует а ссылается на память где стоит изначальный список. Копирование по ссылке
    print(id(s) == id(r)) # True

    r = s[:] # Новый список (новый объект)
    r = list(s) # Новый список (новый объект)
    s.copy() # Копирует список, методом создания нового списка

Распаковка:

.. code:: python

    s = [1, 2, 3, 4]
    a, b, c, d = s   # Распаковка по переменным
    a, *d = s        # a = 1  d = [2, 3, 4]

    us = ['list', 23]

    def us_inf(name, qty): # Передача позиционных аргументов
        if not qty:
            return f'{name} просто текст'
        return f'{name} просто текст {qty}'
    print(us_inf(*us)) # * Распаковывает в 2 разных аргумента.


    # Метод split
    string1 = 'switchport trunk allowed vlan 10,20,30,100-200'
    commands = string1.split()
    print(commands) # ['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']

    #По умолчанию в качестве разделителя используются пробельные символы (пробелы, табы, перевод строки), 
    #но в скобках можно указать любой разделитель:
    vlans = commands[-1].split(',')
    print(vlans) #['10', '20', '30', '100-200']

    #Метод join() позволяет объеденить список, кортеж или словарь в строку разделяя ее елементы другой строкой.
    myTuple = ["John", "Peter", "Vicky"]
    x = "-".join(myTuple)
    print(x) #John-Peter-Vicky

Словари
^^^^^^^

Словарь (dict) — это изменяемая структура данных вида ключ → значение, 
где:
доступ идёт по ключу
порядок элементов сохраняется
ключи — только неизменяемые типы (строки, числа, кортежи)
значения — любые типы
можно добавлять, менять и удалять элементы

.. code:: python

    london = {
    'id': 1, # id -ключ, 1 - значение
    'name':'London',
    'it_vlan':320,
    'user_vlan':1010,
    'mngmt_vlan':99,
    'to_name': None,
    'to_id': None,
    'port':'G1/0/11'
    }

Для того, чтобы получить значение из словаря, надо обратиться по ключу:

.. code:: python

    london = {'name': 'London1', 'location': 'London Str'}
    print(london['name'], london['location'])  #'London1' 'London Str'

Словари записываются в фигурных скобках и содержат пары ключ: значение.
Они удобны, когда нужно связать набор данных с именованными ключами, например, 
описать свойства объекта.

.. code:: python

    color = 'color' # строка неизменяемые данные
    D = {'food': 'Spam', 'quantity': 4, color: 'pink'} # переменая может быть ключем если в ней неизменяемые данные

Мы можем индексировать этот словарь по ключу, чтобы извлекать и изменять зна­ чения, 
связанные с ключами.
Операция индексации словаря имеет такой же синтак­сис, как для последовательностей, 
но элементом вквадратных скобках будет ключ, а не относительная позиция:

.. code:: python

    D['food'] # Извлечь значение, связанное с ключом 'food' 'Spam'
    D['quantity'] += 1 # Добавить 1 к значению, связанному с ключом 'quantity'
    print(D)
    #{'color': 'pink', 'food': 'Spam', 'quantity': 5}

Хотя словари часто создают сразу в фигурных скобках, на практике их нередко заполняют 
постепенно во время работы программы. Можно начать с пустого словаря и добавлять 
элементы по ключу — если ключа ещё нет, он создаётся автоматически.

.. code:: python

    D = {}
    D['name'] = 'Bob'
    D['job'] = 'dev'
    D['age'] =40
    print (D)
    #{'*:age 40, 'job': 'dev', 'name': 'Bob'}
    print(D['name']) #Bob

В словаре в качестве значения можно использовать словарь:

.. code:: python

    london_co = {
        'r1': {
            'hostname': 'london_r1',
            'location': '21 New Globe Walk',
            'vendor': 'Cisco',
            'model': '4451',
            'ios': '15.4',
            'ip': '10.255.0.1'
        },
        'r2': {
            'hostname': 'london_r2',
            'location': '21 New Globe Walk',
            'vendor': 'Cisco',
            'model': '4451',
            'ios': '15.4',
            'ip': '10.255.0.2'
        },
        'sw1': {
            'hostname': 'london_sw1',
            'location': '21 New Globe Walk',
            'vendor': 'Cisco',
            'model': '3850',
            'ios': '3.6.XE',
            'ip': '10.255.0.101'
        }
    }

    # Доступ к данным вложенного словаря
    london_co['r1']['ios'] #'15.4'
    london_co['r1']['model'] #'4451'
    london_co['sw1']['ip'] #'10.255.0.101'


.. code:: python

    # Сравнение словарей
    my_dict = {'1': 'get', 'res': 'get', 'wed': 'gas',}
    my_dict2 = {'res': 'get', '1': 'get', 'wed': 'gas',}

    print(my_dict == my_dict2) # True 
    print(id(my_dict) == id(my_dict2)) # False  разные объекты

    # Изменение словаря
    my_dict2['res'] = 7000  # Изменение значения
    my_dict2['is_new'] = True # Добавления ключа и значения, если такой ключ есть то перепишет значение
    del my_dict2['is_new'] # удаление ключа

    # Безопасное получение значения
    print(my_dict2['eslinetklucha']) # Если нет ключа выдаст ошибку KeyError
    print(my_dict2.get('eslinetklucha')) # Если нет ключа вернет None  ошибки не будет
    print(my_dict2.get('eslinetklucha', 'Нет ключа')) # Если нет ключа вернет второй аргумент 'Нет ключа'
    
    # Просмотр содержимого
    print(my_dict2.items()) # Вызывает экземпляр класса виде кортеджей в списке
    print(my_dict2.keys()) # Вызывает ключи не в списке, конвертация list()
    print(my_dict2.popitem()) # Удаление последний добавленный ключ элемента

    # Удаление элементов
    dmy_dict2.popitem()  # удалить последний добавленный ключ
    del my_dict2['res'] # удалить по ключу

    # Копирование словаря
    print(my_dict2.copy()) # Копия, если не надо изменять оригинал

    # Преобразование в словарь
    my_list =[['first', 0], ['two', 2]]
    my_dict = dict(my_list) # Конвертация из списка в словарь

    # Распаковка
    my_dict = {'1': 'get', 'res': 'get',}
    red = {      # Важна последовательность распаковки и ключа. так как может перезаписать ключ как в первом так и во втором значении
    **my_dict # Распаковывает словарь my_dict (два ключа и 2 значения)
    'wed': 'gas', # Если есть такой ключ то значение перезапишут
    }  

    # Объединение словарей
    my = {**my_dict, **red}
    my = my_dict | red # Объединение словарей. Важна последовательность если одинаковые ключи


Методы для работы со словарями
""""""""""""""""""""""""""""""

**clear()**

- позволяет очистить словарь:

.. code::python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'model': '4451', 'ios': '15.4'}
    london.clear()
    print(london) #{}

**copy()**

- создает полную копию словаря

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    london2 = london.copy()
    id(london) #25524512
    id(london2) #25563296
    london['vendor'] = 'Juniper'
    london2['vendor'] #'Cisco'

.. note::

    Если указать, что один словарь равен другому,
    то london2 будет ссылкой на словарь. И при изменениях словаря london меняется и словарь london2, так как это ссылки на один и тот же объект.


**get()**

- запрашивает ключ, и если его нет, вместо ошибки возвращает None.

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    print(london.get('ios')) #None

    #Метод get() позволяет также указывать другое значение вместо None
    print(london.get('ios', 'Ooops')) #Ooops

**setdefault()**

 - ищет ключ, и если его нет, вместо ошибки создает ключ со значением None, если ключ есть, setdefault возвращает значение, которое ему соответствует:

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    ios = london.setdefault('ios')
    print(ios) #None
    london #{'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': None}
    london.setdefault('name') #'London1'

    #Второй аргумент позволяет указать, какое значение должно соответствовать ключу
    model = london.setdefault('model', 'Cisco3580')
    print(model) #Cisco3580
    london
    {'name': 'London1',
     'location': 'London Str',
     'vendor': 'Cisco',
     'ios': None,
     'model': 'Cisco3580'}

    # Метод setdefault заменяет такую конструкцию:
    if key in london:
         value = london[key]
    else:
         london[key] = 'somevalue'
         value = london[key]


**keys(), values(), items()**

Все три метода возвращают специальные объекты view, которые отображают ключи, значения и пары ключ-значение словаря соответственно.

Очень важная особенность view заключается в том, что они меняются вместе с изменением словаря. И фактически они лишь дают способ посмотреть на соответствующие объекты, но не создают их копию.

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    keys = london.keys()
    print(keys)
    #dict_keys(['name', 'location', 'vendor'])

    #Сейчас переменной keys соответствует view dict_keys, в котором три ключа: name, location и vendor.
    #Но, если мы добавим в словарь еще одну пару ключ-значение, объект keys тоже поменяется:
    london['ip'] = '10.1.1.1'
    keys
    #dict_keys(['name', 'location', 'vendor', 'ip'])

    #Если нужно получить обычный список ключей, который не будет меняться с изменениями словаря, достаточно конвертировать view в список:
    list_keys = list(london.keys())
    list_keys
    #['name', 'location', 'vendor', 'ip']

**del()**

Удаляет ключ и значение

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    del london['name']
    london
    #{'location': 'London Str', 'vendor': 'Cisco'}

**update()**

Позволяет добавлять в словарь содержимое другого словаря:

.. code:: python

    r1 = {'name': 'London1', 'location': 'London Str'}
    r1.update({'vendor': 'Cisco', 'ios':'15.2'})
    r1
    # {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': '15.2'}

    #Аналогичным образом можно обновить значения:
    r1.update({'name': 'london-r1', 'ios':'15.4'})
    r1
    '''
    {'name': 'london-r1',
     'location': 'London Str',
     'vendor': 'Cisco',
     'ios': '15.4'}
    '''

Кортежи
^^^^^^^

Объект кортежа нельзя изменять — кортежи являются последовательностями. 
Функционально они используются для представления фиксированных коллекций элементов: 
скажем, компонентов специфической даты в календаре. 
Синтаксически записываются в круглых, а не квадратных скобках и поддерживают 
произвольные типы, произвольное вложение и обычные операции над последовательностями:

.. code:: python

    T = (1, 2, 3, 4)       # Кортеж из 4 элементов
    len(Т)                 # Длина 4
    Т + (5, б)             # Конкатенация (1, 2, 3, 4, 5, 6)
    Т[О]                   # Индексация, нарезание и т.д.
    tuple2 = ('password',) # в одноэлементные кортежи необходимо добавлять запятую

.. note::

    Главное отличие кортежей заключается в том, что после создания их нельзя из­ менять, т.е. они
    являются неизменяемыми последовательностями.



На практике кортежи применяются в целом не так часто, как списки, но весь смысл в их неизменяемости.
Если вы передаете коллекцию объектов внутри своей программы в виде списка, тогда он может быть
модифицирован где угодно; если вы используете кортеж, то изменить его не удастся. То есть кортежи
обеспечивают своего рода ограничение целостности, что удобно в программах, крупнее тех, которые мы будем
писать здесь.

.. code:: python

    my_tuple  = (1, 2, 3, )
    my_tuple2  = (3, 2, 1, )
    print(my_tuple == my_tuple2) # False  разная последовательность значения
    print(my_tuple[0])           # Взятие элемента по индексу (неудобно и легко ошибиться.)

Методы 

.. code:: python

    my_tuple = (1, [2, 1], 3, 1)
    print(my_tuple.count(1)) # 1  Количество элементов  в кортеже, непоказывает во вложеных
    print(my_tuple.index(1) # Возвращает индекс найденного первого элемента
    print(my_tuple.index(1, 3+1) # второй аргумент, с какого индекса искать

    tuple(list(my_tuple)) # Ковертируем кортеж в список, меняем значение, и конвертируем в картеж

    my_dict = {'1': 'get', 'res': 'get', 'wed': 'gas',}
    print(tuple(my_dict)) # ('1', 'res', 'wed') конверирование списка в кортеж, выдаст кортеж из ключей

    my_type  = (1, 2, 3)
    my_type2  = ('a', 'b', 'c')
    print(my_type + my_type2)     # Объединяет кортежи

Именованные кортежи
"""""""""""""""""""
Именованные кортежи (namedtuple) — это особый вид кортежей в Python, который позволяет 
обращаться к элементам по имени, а не только по индексу.

.. code:: python

    # Модуль collections входит в стандартную библиотеку Python
    from collections import namedtuple  # Импортируем функцию namedtuple из модуля collections

    Person = namedtuple("Person", ["name", "age", "job"])   # Создаём новый тип данных 'Person' с именованными полями: name, age, job
                                                            # Это позволяет хранить связанные данные в объекте с доступом по имени, а не по индексу
    person = Person("Mike", 25, "Programmer")               # Создаём экземпляр типа Person с конкретными значениями полей
                                                            # В нашем случае: name="Mike", age=25, job="Programmer"
    print(person.age)   # 25
    print(person.name)  # Mike

    # --- Получаем список полей ---
    print(person._fields)  # ('name', 'age', 'job')

    # --- Преобразование в словарь ---
    person_dict = person._asdict()
    print(person_dict)  # {'name': 'Mike', 'age': 25, 'job': 'Programmer'}

    # --- Создание нового экземпляра с изменённым полем ---
    # namedtuple неизменяем, поэтому для "изменения" создаём новый экземпляр
    new_person = person._replace(age=30)
    print(new_person)  # Person(name='Mike', age=30, job='Programmer')

    # --- Разложение на переменные (распаковка) ---
    name, age, job = person
    print(name, age, job)  # Mike 25 Programmer

    # --- Получаем значения как обычный кортеж ---
    tuple_person = tuple(person)
    print(tuple_person)  # ('Mike', 25, 'Programmer')

    # --- Проверка неизменяемости ---
    try:
        person.age = 26  # Ошибка! namedtuple неизменяемый
    except AttributeError as e:
        print(e)  # "can't set attribute"

    # Сортируем по возрасту
    people_sorted = sorted(people, key=lambda p: p.age)
    for p in people_sorted:
        print(p.name, p.age)

Именованные кортежи подходят, когда нужно:
хранить простые структуры данных
иметь ясные имена полей
но при этом не создавать полноценные классы
и сохранить скорость и малую память, как у кортежей

Например: координаты, параметры, настройки, результаты вычислений и т.д.

Множество
^^^^^^^^^

Множество(набор) - это изменяемый неупорядоченный тип данных. 
В множестве всегда содержатся только уникальные элементы.
Множество в Python - это последовательность элементов, которые разделены между 
собой запятой и заключены в фигурные скобки.
С помощью множества можно легко убрать повторяющиеся элементы:

.. code:: python

    my_set = set() # Создание пустого набора

    cities = ['Санкт-Петербург', 'Хабаровск', 'Казань', 'Санкт-Петербург', 'Казань']
    un_cities = set(cities) 

    for city in un_cities:
        print("Один мой друг живёт в городе " + city)

    # Один мой друг живёт в городе Хабаровск
    # Один мой друг живёт в городе Санкт-Петербург
    # Один мой друг живёт в городе Казань

Множества полезны тем, что с ними можно делать различные операции и находить объединение 
множеств, пересечение и так далее.
Объединение множеств можно получить с помощью метода union() или оператора "|":

.. code:: python

    my_set2  = {[1], [2], 3} #TypeError  в наборе не могут находится изменяемые элементы

    # Объединение уникальные элементы
    vlans1 = {10,20,30,50,100}
    vlans2 = {100,101,102,102,200}
    vlans1.union(vlans2) #{10, 20, 30, 50, 100, 101, 102, 200}
    vlans1 | vlans2 #{10, 20, 30, 50, 100, 101, 102, 200}

    #Пересечение множеств можно получить с помощью метода intersection() или оператора &
    vlans1 = {10,20,30,50,100}
    vlans2 = {100,101,102,102,200}
    vlans1.intersection(vlans2) #{100} # Выводит повторяющие элементы
    vlans1 & vlans2 #{100} # Выводит повторяющие элементы

Методы 

.. code:: python

    .difference() # разница между множествами
    .discard() # Удаляет множества
    .copy() # Удаляет множества
    .symmetric_difference() # Выдаст элементы отсутствующих в другом множестве и пересечении

.. warning::
    Нельзя создать пустое множество с помощью {}
    (так как в таком случае это будет не множество, а словарь):

    set1 = {}    # создается пустой словарь
    type(set1)   # dict

    set2 = set() # создается пустое множество
    type(set2)   # set


Методы для работы с множествами
"""""""""""""""""""""""""""""""

**add()**

добавляет элемент во множество:

.. code:: python


    set1 = {10,20,30,40}
    set1.add(50)
    set1 #{10, 20, 30, 40, 50}

**discard()**

позволяет удалять элементы, не выдавая ошибку, если элемента в множестве нет

.. code:: python

    set1 #{10, 20, 30, 40, 50}
    set1.discard(55)
    set1 #{10, 20, 30, 40, 50}
    set1.discard(50)
    set1 #{10, 20, 30, 40}

**clear()**

очищает множество

.. code:: python

    set1 = {10,20,30,40}
    set1.clear()
    set1 #set()

Булевы значения
^^^^^^^^^^^^^^^

Булевы значения это две константы True - истина и False - лож. 

Истинное значение:

.. code:: python

    1                   # True - Короткая запись истины 1
    print(bool(10))     # True - любое ненулевое число
    print(bool('abc'))  # True - любая непустая строка
    print(bool([1, 2])) # True - любой непустой объект
    print([] == [])

    # Выражение 
    print(100>10)                 # True первое число больше второго
    print('long string'>'Long')   # True первая сторока больше второй

Ложное значение:

.. code:: python

    1                 # False - Короткая запись лож 0
    print(bool(None)) # False None - без значения
    print(bool(""))   # False Пустая строка, список, кортедж и т.д.
    

Остальные истинные и ложные значения, как правило, логически следуют из условия.

Для проверки булевого значения объекта, можно воспользоваться bool:

.. code:: python

    items = [1, 2, 3]
    empty_list = []
    bool(empty_list) #False
    bool(items) #True
    bool(0) #False
    bool(1) #True

Лексикографическое сравнение строк в Python

Строки сравниваются посимвольно, по Unicode-кодам.
Если первые символы одинаковы, Python сравнивает следующие, пока не найдёт различие

.. code:: python

    print('long string' > 'Long') # True  
    print('long string' > 'Short') #True Первый символ 'l' (код 108) и 'S' (код 83). Поскольку 108 > 83, 
                                   # Python сразу решает, что строка 'long string' больше, чем 'Short', и не продолжает сравнение дальше.
    print('long' > 'long') # False
    print('a' > 'at') # False Сначала сравнивается первый символ обеих строк — 'a' и 'a'  Строка 'a' не имеет второго символа, а строка 'at' имеет 't' на второй позиции.
                      # поскольку строка 'a' короче, чем 'at', Python считает её меньшей, и результат сравнения будет False
    print('long string' > 'Short string') # True  Строки сравниваются на основе их символов, используя их числовые коды (Unicode). 
                                          # 'l' (номер в Unicode 108) и 'S' (номер 83). 108 > 83
    print('long' == 'long') # True
    print('long string' == 'Long string') # False учитывает регистр
    print('Long string' == 'Short string') # False учитывает значение
    print('Long string' == 'Long  string') # False учитывает пробел

Преобразование типов
--------------------

В Python есть несколько полезных встроенных функций, которые позволяют преобразовать
данные из одного типа в другой.

Конвертация строки в двоичную, десятичную, шестнадцатеричную систему.

.. code:: python

    # Преобразует строку как двоичное число в десятичное:
    int("11111111", 2) # 255  С помощью функции int можно преобразовать и число в двоичной записи в десятичную (двоичная запись должна быть в виде строки)

    # Преобразовать десятичное число в двоичный формат можно с помощью:
    bin(10) #'0b1010'

    # Преобразовать десятичное число в шестнадцатеричный формат:
    hex(10) #'0xa'

Преобразование типов

.. code:: python

    # Преобразует в список:
    list("string")     #['s', 't', 'r', 'i', 'n', 'g']
    list({1,2,3})      #[1, 2, 3]
    list((1,2,3,4))    #[1, 2, 3, 4

    # Преобразует  в множество:
    set([1,2,3,3,4,4,4,4]) #{1, 2, 3, 4}
    set((1,2,3,3,4,4,4,4)) #{1, 2, 3, 4}
    set("string string")   #{' ', 'g', 'i', 'n', 'r', 's', 't'}

    # Преобразует  в кортеж:
    tuple([1,2,3,4])   #(1, 2, 3, 4)
    tuple({1,2,3,4})   #(1, 2, 3, 4)
    tuple("string")    #('s', 't', 'r', 'i', 'n', 'g')

    # Преобразует число в строку:
    str(10)            #'10'

    # Преобразует строку в цифру:
    int("10")          #10

    # Преобразует в число с плавающей точкой:
    a = float("3.14")  # строка '3.14' преобразуется в число 3.14
    b = float(10)      # целое число 10 преобразуется в 10.0



Проверка типов
--------------

.. code:: python

    # Проверяет, сосоит ли строка из одних только цифр
    "a".isdigit() #False
    "a10".isdigit() #False
    "10".isdigit() #True

    # Проверяет, состоит ли строка из одних букв:
    "a".isalpha() #True
    "a100".isalpha() #False
    "a--  ".isalpha() #False
    "a ".isalpha() #False

    # Позволяет проверить, состоит ли строка из букв или цифр:
    "a".isalnum() #True
    "a10".isalnum() #True

**type()**

Иногда, в зависимости от результата, библиотека или функция может выводить разные 
типы объектов. Например, если объект один, возвращается строка, если несколько, 
то возвращается кортеж.

Нам же надо построить ход программы по-разному, в зависимости от того, была ли 
возвращена строка или кортеж.

.. code:: python

    type("string") #str
    type("string") is str #True

    #Аналогично с кортежем (и другими типами данных):
    type((1,2,3)) #tuple
    type((1,2,3)) is tuple #True
    type((1,2,3)) is list #False

Файлы
-----

Объекты файлов являются главным интерфейсом к внешним файлам на компью­ тере.
Они могут применяться для чтения и записи текстовых заметок, аудиоклипов,
документов Excel, сохраненных сообщений электронной почты и всего того, что вы в итоге
сохранили на своем компьютере. Файлы относятся к основным типам, но они кое в чем своеобразны — специфический
литеральный синтаксис для их создания от­ сутствует, Взамен, чтобы создать объект файла,
необходимо вызвать встроенную фун­ кцию open, передав ей в виде строк имя внешнего файла и необязательный
режим обработки.

Например, для создания выходного текстового файла понадобится передать его имя и строку режима обработки ’ w ’, чтобы записывать данные:

.. code:: python

    f = open('data.txt' , 'w') # Создать новый файл в режиме записи ('w')
    f.write('Hello\n') # Записать в него строки символов
    f.write ('world\n') # Возвратить количество записанных элементов
    f.close()   # Закрыть для сбрасывания буферов вывода на диск

Код создает файл в текущем каталоге и записывает в него текст (имя файла мо­ жет содержать полный путь к каталогу,
если нужно получить доступ к файлу где-то в другом месте на компьютере). Чтобы прочитать то, что было записано,
необходимо повторно открыть файл в режиме обработки ’ г ’ для чтения текстового ввода (он вы­ бирается по умолчанию,
если в вызове строка режима не указана). Затем следует про­ читать содержимое файла в строку и отобразить ее.
В сценарии содержимое файла всегда будет строкой независимо от типа находящихся в нем данных:

.. code:: python

    f = open('data.txt')    # 'г' (чтение) - стандартный режим обработки
    text = f.read()         # Прочитать все содержимое файла в строку
    text                    #'Hello\nworld\n'
    print(text)             # print интерпретирует управляющие символы
    #Hello
    #world
    text.split()            # Содержимое файла - всегда строка
    #['Hello', 'world']

.. note::

    Обратите внимание, что для того что бы прочесь все строки из файла, нам нужно обернуть функцию чтения в цикл
    for line in open(’data.txt’): print(line)

    так же не забывайте закрывать файл после операции чтения или записи
    f.close

.. note::

    Ранее в примере с подсчетом слов мы использовали друую констукцию

        with open(filename, encoding="utf8") as file: #эта строка открывает файл
            text = file.read()  #читаем содержимое файла и записываем все в переменную text

            text = text.replace("\n", " ") #преобразуем наш текст в одну длинную строку заменив символ перевода строки на пробел

            text = text.replace(",", "").replace(".", "").replace("?", "").replace("!", "") #а так же уберем все запетые, пробелы, и прочие знаки пунктуации

            text = text.lower()  #перведем все слова в строчные, тоесть если было "Начало изучения Языка Программирования", то будет "начало изучения языка программирования"

            words = text.split() #создадим список слов ("списки", "выгледят", "вот","так")

            words.sort()

    Такой подход позволяет не закрывать файл в ручную.


Операторы языка Python
----------------------

Большинство предложений (логических строк) в программах содержат выражения. Простой пример выражения: 2 + 3.
Выражение можно разделить на операторы и операнды.

Операторы – это некий функционал, производящий какие-либо действия, который может быть представлен в виде символов,
как например +, или специальных зарезервированных слов. Операторы могут производить некоторые действия над данными,
и эти данные называются операндами. В нашем случае 2 и 3 – это операнды.

Базовые операторы
^^^^^^^^^^^^^^^^^

далее стоит привести таблицу операторов:


+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| Оператор |  Название                      |  Объяснение                                     |  Примеры                                                               |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| '+'      |  Сложение                      |  Суммирует два объекта                          |  3 + 5 даст 8; 'a' + 'b' даст 'ab'                                     |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| '-'      |  Вычитание                     |  Даёт разность двух чисел; если первый операнд  |                                                                        |
|          |                                |  отсутствует, он считается равным нулю          |  -5.2 даст отрицательное число, а 50 - 24 даст 26.                     |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| '*'      |  Умножение                     |  Даёт произведение двух чисел или возвращает    |                                                                        |
|          |                                |  строку, повторённую заданное число раз.        |  2 * 3 даст 6. 'la' * 3 даст 'lalala'.                                 |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| '**'     |  Возведение в степень          |  Возвращает число х, возведённое в степень y    |  3** 4 даст 81 (т.е. 3 * 3 * 3 * 3)                                    |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| /        |  Деление                       |  Возвращает частное от деления x на y           |  4 / 3 даст 1.3333333333333333.                                        |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| //       |  Целочисленное деление         |  Возвращает неполное частное от деления         |  4 // 3 даст 1. -4 // 3 даст -2.                                       |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| %        |  Деление по модулю             |  Возвращает остаток от деления                  |  8 % 3 даст 2. -25.5 % 2.25 даст 1.5.                                  |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| <<       |  Сдвиг влево                   |  Сдвигает биты числа влево на заданное          |  2 << 2 даст 8. В двоичном виде 2 представляет собой 10.               |
|          |                                |  количество позиций. (Любое число в памяти      |  Сдвиг влево на 2 бита даёт 1000, что в десятичном виде означает 8.    |
|          |                                |  компьютера представлено в виде битов - или     |                                                                        |
|          |                                |  двоичных чисел, т.е. 0 и 1)                    |                                                                        |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| >>       |  Сдвиг вправо                  |  Сдвигает биты числа вправо на заданное         |  11 >> 1 даст 5. В двоичном виде 11 представляется как 1011,           |
|          |                                |  число позиций.                                 |  что будучи смещённым на 1 бит вправо, даёт 101, а это, в свою         |
|          |                                |                                                 |  очередь, не что иное как десятичное 5                                 |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| &        |  Побитовое И                   |  Побитовая операция И над числами               |  5 & 3 даёт 1.                                                         |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| '|'      |  Побитовое ИЛИ                 |  Побитовая операция ИЛИ над числами             |  5 | 3 даёт 7                                                          |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| ^        |  Побитовое ИСКЛЮЧИТЕЛЬНО ИЛИ   |  Побитовая операция ИСКЛЮЧИТЕЛЬНО ИЛИ           |  5 ^ 3 даёт 6                                                          |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| ~        |  Побитовое НЕ                  |  Побитовая операция НЕ для числа x              |                                                                        |
|          |                                |   соответствует -(x+1)                          |  ~5 даёт -6.                                                           |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| <        |  Меньше                        |  Определяет, верно ли, что x меньше y.          |                                                                        |
|          |                                |  Все операторы сравнения возвращают             |  5 < 3 даст False,                                                     |
|          |                                |  True или False [1]. Обратите внимание на       |  а 3 < 5 даст True.                                                    |
|          |                                |  заглавные буквы в этих словах.                 |  Можно составлять произвольные цепочки сравнений: 3 < 5 < 7 даёт True. |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| >        |  Больше                        |  Определяет, верно ли, что x больше y           |  5 > 3 даёт True. Если оба операнда - числа, то перед сравнением       |
|          |                                |                                                 |  они оба преобразуются к одинаковому типу. В противном случае всегда   |
|          |                                |                                                 |  возвращается False.                                                   |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| <=       |  Меньше или равно              |  Определяет, верно ли, что x меньше или равно y |  x = 3; y = 6; x <= y даёт True.                                       |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| >=       |  Больше или равно              |  Определяет, верно ли, что x больше или равно y |  x = 4; y = 3; x >= 3 даёт True.                                       |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| ==       |  Равно                         |  Проверяет, одинаковы ли объекты                |  x = 2; y = 2; x == y даёт True. x = 'str'; y = 'stR';                 |
|          |                                |                                                 |  x == y даёт False. x = 'str'; y = 'str'; x == y даёт True.            |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| !=       |  Не равно                      |  Проверяет, верно ли, что объекты не равны      |  x = 2; y = 3; x != y даёт True.                                       |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| not      |  Логическое НЕ                 |  Если x равно True, оператор вернёт False.      |                                                                        |
|          |                                |  Если же x равно False, получим True.           |  x = True; not x даёт False.                                           |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| and      |  Логическое И                  |  x and y даёт False, если x равно False ,       |  x = False; y = True; x and y возвращает False, поскольку x равно      |
|          |                                |  в противном случае возвращает значение y       |  False. В этом случае Python не станет проверять значение y,           |
|          |                                |                                                 |  так как уже знает, что левая часть выражения 'and' равняется False,   |
|          |                                |                                                 |  что подразумевает, что и всё выражение в целом будет равно False,     |
|          |                                |                                                 |  независимо от значений всех остальных операндов. Это называется       |
|          |                                |                                                 |  укороченной оценкой булевых (логических) выражений.                   |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+
| or       |  Логическое ИЛИ                |  Если x равно True, в результате получим True,  |  x = True; y = False; x or y даёт True.                                |
|          |                                |  в противном случае получим значение y          |  Здесь также может производиться укороченная оценка выражений.         |
+----------+--------------------------------+-------------------------------------------------+------------------------------------------------------------------------+

Управляющие операторы
^^^^^^^^^^^^^^^^^^^^^

Условные операторы (if/else)
""""""""""""""""""""""""""""
Оператор if используется для проверки условий: если условие верно, выполняется блок выражений (называемый “if-блок”),
иначе выполняется другой блок выражений (называемый “else-блок”). Блок “else” является необязательным.

.. warning::
    
    В языке Python блоки разедяются табами или пробелами

    Запомните эмпирическое правило: хотя вы можете использовать для отступов пробелы или табуляции, их смешивание внутри блока обычно не будет удачной иде­ей
    применяйте либо то, либо другое. Формально табуляция считается достаточным количеством пробелов, чтобы сместить текущую строку на расстояние, кратное 8,
    и код будет работать в случае согласованного смешивания табуляций и пробелов. Тем не менее, такой код может быть сложнее изменять. Хуже того, смешивание
    табуляций и пробелов затрудняет чтение кода целиком, не говоря уже о правилах синтаксиса Python — табуляции в редакторе сменившего вас программиста могут
    выглядеть сов­ сем не так, как в вашем редакторе.


Пример использования оператора if

.. code:: python

    number = 23
    guess = int(input('Введите целое число : '))

    if guess == number:
        print('Поздравляю, вы угадали,') # Здесь начинается новый блок
        print('(хотя и не выиграли никакого приза!)') # Здесь заканчивается новый блок
    elif guess < number:
        print('Нет, загаданное число немного больше этого.') # Ещё один блок
        # Внутри блока вы можете выполнять всё, что угодно ...
    else:
        print('Нет, загаданное число немного меньше этого.')
        # чтобы попасть сюда, guess должно быть больше, чем number

    print('Завершено')
    # Это последнее выражение выполняется всегда после выполнения оператора if


Оператор while
""""""""""""""

Оператор while — самая универсальная конструкция для итераций в языке Python. Выражаясь простыми терминами, он многократно выполняет блок операторов
(обыч­ но с отступом) до тех пор, пока проверка в заголовочной части оценивается как истин­ ное значение. Это называется “циклом”,
потому что управление продолжает возвра­ щаться к началу оператора, пока проверка не даст ложное значение. Когда результат проверки становится ложным,
управление переходит на оператор, следующий после блока while. Совокупный эффект в том, что тело цикла выполняется многократно, пока проверка в
заголовочной части дает истинное значение. Если проверка оцени­ вается в ложное значение с самого начала, тогда тело цикла никогда не
выполнится и оператор while пропускается.

В своей самой сложной форме оператор while состоит из строки заголовка с вы­ ражением проверки, тела с одним или большим количеством оператором с отступами
и необязательной части else, которая выполняется, если управление покидает цикл, а оператор break не встретился. Python продолжает оценивать выражение
проверки в строке заголовка и выполняет операторы, вложенные в тело цикла, пока проверка не возвратит ложное значение:


.. code:: python

    number = 23
    running = True

    while running:
        guess = int(input('Введите целое число : '))

        if guess == number:
            print('Поздравляю, вы угадали.')
            running = False # это останавливает цикл while
        elif guess < number:
            print('Нет, загаданное число немного больше этого.')
        else:
            print('Нет, загаданное число немного меньше этого.')
    else:
        print('Цикл while закончен.')
        # Здесь можете выполнить всё что вам ещё нужно

    print('Завершение.')

Цикл for
""""""""
Циклы перебирают последовательности: diсt, set, list, str, range, tuple
Оператор осуществляет итерацию по последовательности
объектов, последовательность – это упорядоченный набор элементов.

.. code:: python

    for х in ["spam", "eggs", "ham"]:
        print(x, end=' ')   # spam
                            # eggs
                            # ham
    # end=' ' меняет поведение print: по умолчанию print() ставит перенос строки \n, 
    # но тут вместо него ставится пробел. Поэтому все значения выводятся в одну строку через пробел:

.. code:: python

    for i in range(1, 5):
        print(i)
    else:
        print('Цикл for закончен')

Вложенные циклы for
~~~~~~~~~~~~~~~~~~~

Давайте теперь взглянем на цикл for, который сложнее тех, что мы видели до сих пор.
В приведенном ниже примере иллюстрируется вложение операторов и конструк­ ция else цикла for.
Имея список объектов (items) и список ключей (tests), код ищет каждый ключ в списке объектов и
сообщает о результате поиска:

.. code:: python

    items = ["ааа", 111, (4, 5), 2.01]
    tests = [(4, 5) , 3.14]

    for key in tests:
        for item in items:
            if item - key:
                print (key, "was found")
                break
            else:
                print(key, "not found!")

Оператор break
""""""""""""""

Оператор break служит для прерывания[7] цикла, т.е. остановки выполнения команд даже если условие выполнения цикла
ещё не приняло значения False или последовательность элементов не закончилась.

Важно отметить, что если циклы for или while прервать оператором break, соответствующие им блоки else выполняться не будут.

.. code:: python
    # Бесконечный цикл
    while  True: # Неизменяемое условие
    print('1')

    while True:
        s = input('Введите что-нибудь : ')
        if s == 'выход':
            break # Выход из цикла
        print('Длина строки:', len(s))
    print('Завершение')

Оператор continue
"""""""""""""""""

Оператор continue используется для указания Python, что необходимо пропустить все оставшиеся команды в текущем блоке цикла и продолжить[9] со следующей итерации цикла.

.. code:: python

    # Прерывание с помощью ввода
    while True:
        s = input('Введите что-нибудь : ')
        if s == 'выход':
            break # Выход из цикла
        if len(s) < 3:
            print('Слишком мало')
            continue # Пропуск операции
        print('Введённая строка достаточной длины')
        # Разные другие действия здесь...

Ну и в качестве маленького примера давайте нарисуем в консоли Ёлочку :)

.. literalinclude:: ../../Examples/herringbone.py
  :language: python

Цикл по словарю (через items())

.. code:: python

    l = {'1': 'зн1', '2': 'зн2', '3': 'зн3'}
    for item in l.items(): #  items() - возвращает последовательность кортеж ключ, пара
        key, value = item # распаковывает кортеж в две переменные:
        print(key, value) 
        
    # Сразу распаковка в цикле    
    for key, value in l.items(): # items() - возвращает последовательность кортежа ключ, пара
        print(key, value) 

Генераторы

Преимущество генераторов, в малом объеме памяти у объекта

.. code:: python

    # Список — генератор списка
    absol = [3, 4, 7, -2, 6, -1] # список чисел.
    absol_1 = [abs(num) for num in absol if num % 2 == 0]   # for num in absol — перебрать каждый элемент
                                                            # if num % 2 == 0 — оставить только чётные числа
                                                            # abs(num) — взять модуль числа (убрать минус)
    print(absol_1)

    # Генератор множества (set comprehension)
    myset = [3, 4, 7, -2, 6, -1]
    new_myset = {val * val for val in myset} # Перебираем каждый элемент val,  Возводим его в квадрат val * val, Результаты собираются в {...} — это множество
    print(new_myset)
    # не хранит дубликаты, не гарантирует порядок

    # Генератор словаря (dict comprehension)
    my_dict = {'1': 10, 'res': 7, 'wed': 14}
    new_tunec = {key: value * 10 for key, value in my_dict.items()} # my_dict.items() даёт пары (ключ, значение)
    print(new_tunec)
    # 

    print(new_myset) # <generator object <genexpr> at 0x000001BDA7046180>
    print(type(new_myset)) # <class 'generator'>

Функции языка Python
--------------------

Функции – это многократно используемые фрагменты программы. Они позволяют дать имя определённому блоку команд с тем,
чтобы впоследствии запускать этот блок по указанному имени в любом месте программы и сколь угодно много раз.
Это называется вызовом функции. Мы уже использовали много встроенных функций, как то len и range.

Функция – это, пожалуй, наиболее важный строительный блок любой нетривиальной программы (на любом языке программирования),
поэтому в этой главе мы рассмотрим различные аспекты функций.

Функции определяются при помощи зарезервированного слова def. После этого слова указывается имя функции, за которым следует
пара скобок, в которых можно указать имена некоторых переменных, и заключительное двоеточие в конце строки.
Далее следует блок команд, составляющих функцию. На примере можно видеть, что на самом деле это очень просто:


.. code:: python

    def sayHello():
        print('Привет, Мир!') # блок, принадлежащий функции
        # Конец функции

    sayHello() # вызов функции
    sayHello() # ещё один вызов функции

Параметры функций
^^^^^^^^^^^^^^^^^

Функции могут принимать параметры, т.е. некоторые значения, передаваемые функции для того, чтобы она что-либо сделала с ними.
Эти параметры похожи на переменные, за исключением того, что значение этих переменных указывается при вызове функции, и во время
работы функции им уже присвоены их значения.

Параметры указываются в скобках при объявлении функции и разделяются запятыми. Аналогично мы передаём значения, когда вызываем функцию.
Обратите внимание на терминологию: имена, указанные в объявлении функции, называются параметрами, тогда как значения, которые вы передаёте
в функцию при её вызове, – аргументами.


.. code:: python

    def printMax(a, b):
        if a > b:
            print(a, 'максимально')
        elif a == b:
            print(a, 'равно', b)
        else:
            print(b, 'максимально')

    printMax(3, 4) # прямая передача значений

    x = 5
    y = 7

    printMax(x, y) # передача переменных в качестве аргументов


Локальные переменные
^^^^^^^^^^^^^^^^^^^^

При объявлении переменных внутри определения функции, они никоим образом не связаны с другими переменными
с таким же именем за пределами функции – т.е. имена переменных являются локальными в функции.
Это называется областью видимости переменной. Область видимости всех переменных ограничена блоком,
в котором они объявлены, начиная с точки объявления имени.


.. code:: python

    x= 50

    def func(x):
        print('x равен', x)
        x = 2
        print('Замена локального x на', x)

    func(x)
    print('x по-прежнему', x)

Зарезервированное слово “global”
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Чтобы присвоить некоторое значение переменной, определённой на высшем уровне программы (т.е. не в какой-либо области видимости,
как то функции или классы), необходимо указать Python, что её имя не локально, а глобально (global). Сделаем это при помощи
зарезервированного слова global. Без применения зарезервированного слова global невозможно присвоить значение переменной,
определённой за пределами функции.

Можно использовать уже существующие значения переменных, определённых за пределами функции (при условии, что внутри функции
не было объявлено переменной с таким же именем). Однако, это не приветствуется, и его следует избегать, поскольку человеку,
читающему текст программы, будет непонятно, где находится объявление переменной. Использование зарезервированного слова
global достаточно ясно показывает, что переменная объявлена в самом внешнем блоке.

.. code:: python

    x = 50

    def func():
        global x

        print('x равно', x)
        x = 2
        print('Заменяем глобальное значение x на', x)

    func()
    print('Значение x составляет', x)

Зарезервированное слово “nonlocal”
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Мы увидели, как получать доступ к переменным в локальной и глобальной области видимости. Есть ещё один тип области видимости,
называемый “нелокальной” (nonlocal) областью видимости, который представляет собой нечто среднее между первыми двумя.
Нелокальные области видимости встречаются, когда вы определяете функции внутри функций.

Поскольку в Python всё является выполнимым кодом, вы можете определять функции где угодно.

.. code:: python

    def func_outer():
        x = 2
        print('x равно', x)

        def func_inner():
            nonlocal x
            x = 5

        func_inner()
        print('Локальное x сменилось на', x)

    func_outer()

Значения аргументов по умолчанию
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Зачастую часть параметров функций могут быть необязательными, и для них будут использоваться некоторые заданные
значения по умолчанию, если пользователь не укажет собственных. Этого можно достичь с помощью значений аргументов
по умолчанию. Их можно указать, добавив к имени параметра в определении функции оператор присваивания (=) с последующим значением.

Обратите внимание, что значение по умолчанию должно быть константой. Или точнее говоря, оно должно быть
неизменным[1] – это объясняется подробнее в последующих главах. А пока запомните это.

.. code:: python

    def say(message, times = 1):
        print(message * times)

    say('Привет')
    say('Мир', 5)

.. warning::
    
    Важно Значениями по умолчанию могут быть снабжены только параметры, находящиеся в конце списка параметров.
    Таким образом, в списке параметров функции параметр со значением по умолчанию не может предшествовать параметру
    без значения по умолчанию. Это связано с тем, что значения присваиваются параметрам в соответствии с их положением.
    Например, def func(a, b=5) допустимо, а def func(a=5, b) – не допустимо.

Ключевые аргументы
^^^^^^^^^^^^^^^^^^

Если имеется некоторая функция с большим числом параметров, и при её вызове требуется указать только некоторые из них,
значения этих параметров могут задаваться по их имени – это называется ключевые параметры. В этом случае для передачи аргументов
функции используется имя (ключ) вместо позиции (как было до сих пор).

Есть два преимущества такого подхода: во-первых, использование функции становится легче, поскольку нет необходимости отслеживать
порядок аргументов; во-вторых, можно задавать значения только некоторым избранным аргументам, при условии, что остальные параметры имеют
значения аргумента по умолчанию.

.. code:: python

    def func(a, b=5, c=10):
        print('a равно', a, ', b равно', b, ', а c равно', c)

    func(3, 7)
    func(25, c=24)
    func(c=50, a=100)


Переменное число параметров
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Иногда бывает нужно определить функцию, способную принимать любое число параметров. Этого можно достичь при помощи звёздочек (сохраните как function_varargs.py):


.. code:: python

    def total(a=5, *numbers, **phonebook):
        print('a', a)

        #проход по всем элементам кортежа
        for single_item in numbers:
            print('single_item', single_item)

        #проход по всем элементам словаря
        for first_part, second_part in phonebook.items():
            print(first_part,second_part)

    print(total(10,1,2,3,Jack=1123,John=2231,Inge=1560))


Только ключевые параметры
^^^^^^^^^^^^^^^^^^^^^^^^^

Если некоторые ключевые параметры должны быть доступны только по ключу, а не как позиционные аргументы, их можно
объявить после параметра со звёздочкой (сохраните как keyword_only.py):

.. code:: python

    def total(initial=5, *numbers, extra_number):
        count = initial
        for number in numbers:
            count += number
        count += extra_number
        print(count)

    total(10, 1, 2, 3, extra_number=50)
    total(10, 1, 2, 3)
    # Вызовет ошибку, поскольку мы не указали значение
    # аргумента по умолчанию для 'extra_number'.


Оператор “return”
^^^^^^^^^^^^^^^^^

Оператор return используется для возврата[5] из функции, т.е. для прекращения её работы и выхода из неё. При этом можно также вернуть некоторое значение из функции.

.. code:: python

    #!/usr/bin/python
    # Filename: func_return.py

    def maximum(x, y):
        if x > y:
            return x
        elif x == y:
            return 'Числа равны.'
        else:
            return y

    print(maximum(2, 3))

Строки документации
-------------------

Python имеет остроумную особенность, называемую строками документации, обычно обозначаемую сокращённо docstrings.
Это очень важный инструмент, которым вы обязательно должны пользоваться, поскольку он помогает лучше документировать
программу и облегчает её понимание. Поразительно, но строку документации можно получить, например, из функции, даже во время выполнения программы!

.. code:: python

    def printMax(x, y):
        '''Выводит максимальное из двух чисел.

        Оба значения должны быть целыми числами.'''
        x = int(x) # конвертируем в целые, если возможно
        y = int(y)

        if x > y:
            print(x, 'наибольшее')
        else:
            print(y, 'наибольшее')

    printMax(3, 5)
    print(printMax.__doc__)

Классы
------

Декоратры
---------

Инспекция и dunder-атрибуты
---------------------------

Инспекция объектов (Introspection)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    print(dir(obj))       # Показывает список всех доступных атрибутов и методов объекта
    print(id(obj))        # Показывает уникальный идентификатор (адрес в памяти)
    print(type(obj))      # Показывает тип (класс) объекта
    print(help(obj))      # Показывает встроенную справку по объекту
    print(obj.__doc__)    # Показывает строку документации (docstring)
    print(obj.__dict__)   # Словарь атрибутов объекта
    print(obj.__class__)  # Класс, к которому принадлежит объект
    print(obj.__module__) # Модуль, в котором определён объект
    print(obj.__annotations__)  # Аннотации типов (если есть)
    print(obj.__sizeof__())     # Размер объекта в байтах
    from sys import getsizeof
    print(getsizeof(obj))       # Альтернатива — учитывает служебную информацию

Информация о классах и наследовании
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    print(MyClass.__subclasses__())  # Список всех подклассов данного класса
    print(MyClass.__bases__)         # Кортеж базовых (родительских) классов
    print(MyClass.__mro__)           # Порядок разрешения методов (Method Resolution Order)
    print(MyClass.__name__)          # Имя класса

Магические методы (Dunder methods)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Строковые представления

.. code:: python

    obj.__repr__()   # “Официальное” строковое представление (для разработчиков)
    obj.__str__()    # “Человеческое” строковое представление (для вывода) 

Хэш и сравнения

.. code:: python

    obj.__hash__()   # Возвращает хэш-значение объекта
    obj.__eq__(x)    # Равно ==
    obj.__ne__(x)    # Не равно !=
    obj.__lt__(x)    # Меньше <
    obj.__le__(x)    # Меньше или равно <=
    obj.__gt__(x)    # Больше >
    obj.__ge__(x)    # Больше или равно >=


Прочие специальные атрибуты
^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    obj.__slots__    # Определяет допустимые атрибуты (ограничивает __dict__)


Изменяемость, идентичность, копирование
---------------------------------------

Тип данных и их свойства
^^^^^^^^^^^^^^^^^^^^^^^^

+-------+------------+------------------+---------------------+
| list  | Изменяемый |  упорядоченный   | одинаковые элементы |
+-------+------------+------------------+---------------------+
| tuple |     нет    |  упорядоченный   | одинаковые элементы |
+-------+------------+------------------+---------------------+
| set   | Изменяемый |       нет        |         нет         |
+-------+------------+------------------+---------------------+
| range |     нет    |  упорядоченный   |         нет         |
+-------+------------+------------------+---------------------+
| dict  | Изменяемый |       нет        |         нет         |
+-------+------------+------------------+---------------------+
| str   |     нет    |  упорядоченный   | одинаковые элементы |
+-------+------------+------------------+---------------------+

Адреса объектов в памяти
^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    m_n = 10
    print(id(m_n)) # 2798471414288  
    o_n = 10
    print(id(o_n)) # 2798471414288  

    c_n = m_n
    print(id(m_n)) # 2798471414288  
    print(id(c_n)) # 2798471414288  

    c_n += 5  # создаётся новый объект
    print(id(m_n)) # 2798471414288  
    print(id(c_n)) # другой адрес

**Примечание:** неизменяемые объекты (int, str, tuple) при изменении создают новую копию в памяти,  
а изменяемые (list, dict, set) — работают по ссылке.

Поверхностное и глубокое копирование
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    from copy import deepcopy

    info_deepcopy = deepcopy(словарь)  
    # Возвращает новый объект с копиями всех вложенных структур.

    def copy_fn(person):
        person_copy = person.copy()  # поверхностная копия
        person_copy["age"] += 2
        return person_copy

**Разница:**  
`copy()` создаёт копию только верхнего уровня (не вложеные объекты).  
`deepcopy()` — рекурсивно копирует все вложенные объекты.  
`=` просто создаёт новую ссылку на тот же объект в памяти.












Модули
======

Список
------

Описание
--------

Файлы байткода .pyc
^^^^^^^^^^^^^^^^^^^

Импорт модуля – относительно дорогостоящее мероприятие, поэтому Python предпри- нимает некоторые трюки
для ускорения этого процесса. Один из способов – создать байт-компилированные файлы (или байткод)
с расширением .pyc, которые являются некой промежуточной формой, в которую Python переводит программу
(помните раздел “Введение” о том, как работает Python?). Такой файл .pyc полезен при импорте модуля в
следующий раз в другую программу – это произойдёт намного быстрее, поскольку зна- чительная часть обработки,
требуемой при импорте модуля, будет уже проделана. Этот байткод также является платформо-независимым.

.. note::
    Обычно файлы .pyc создаются в том же каталоге, где расположены и соот- ветствующие им файлы .py.
    Если Python не может получить доступ для записи файлов в этот каталог, файлы .pyc созданы не будут.


Оператор from ... import ...
^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Чтобы импортировать переменную argv прямо в программу и не писать всякий раз sys. при обращении к ней,
можно воспользоваться выражением "from sys import argv".
Для импорта всех имён, использующихся в модуле sys, можно выполнить команду "from sys import """*"""".
Это работает для любых модулей.
В общем случае вам следует избегать использования этого оператора и использовать вместо этого оператор
import, чтобы предотвратить конфликты имён и не затруднять чтение программы.

.. code:: python

    from math import *
    n = input("Введите диапазон:- ") p = [2, 3]
    count = 2
    a=5
    while (count < n):
        b=0
        for i in range(2,a):
            if ( i <= sqrt(a)): if (a % i == 0):
                print("a neprost",a)
                b=1
            else:
                pass
        if (b != 1):
            print("a prost",a) p = p + [a]
        count = count + 1
        a=a+2
    print p


Имя модуля – __name__
^^^^^^^^^^^^^^^^^^^^^

У каждого модуля есть имя, и команды в модуле могут узнать имя их модуля. Это полез- но, когда нужно знать,
запущен ли модуль как самостоятельная программа или импорти- рован. Как уже упоминалось выше, когда модуль
импортируется впервые, содержащийся в нём код исполняется. Мы можем воспользоваться этим для того, чтобы
заставить мо- дуль вести себя по-разному в зависимости от того, используется ли он сам по себе или
импортируется в другую программа. Этого можно достичь с применением атрибута мо- дуля под названием __name__.

.. code:: python

    if __name__ == '__main__':
        print('Эта программа запущена сама по себе.')
    else:
        print('Меня импортировали в другой модуль.')

**Как это работает:**
    В каждом модуле Python определено его имя – __name__ . Если оно равно '__main__', это означает,
    что модуль запущен самостоятельно пользователем, и мы можем выполнить соответствующие действия.

Создание собственных модулей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Создать собственный модуль очень легко. Да вы всё время делали это! Ведь каждая про- грамма на Python
также является и модулем. Необходимо лишь убедиться, что у неё уста- новлено расширение .py.
Следующий пример объяснит это.


.. code:: python

    # mymodule.py

    def sayhi():
        print('Привет! Это говорит мой модуль.')
    __version__ = '0.1'

Выше приведён простой модуль. Как видно, в нём нет ничего особенного по сравнению с обычной программой
на Python. Далее посмотрим, как использовать этот модуль в дру- гих наших программах.
Помните, что модуль должен находиться либо в том же каталоге, что и программа, в ко- торую мы импортируем
его, либо в одном из каталогов, указанных в sys.path.

.. code:: python

    # mymodule_demo.py

    import mymodule

    mymodule.sayhi()
    print ('Версия', mymodule.__version__)


.. note::

    Обратите внимание, что мы используем всё то же обозначение точкой для до- ступа к элементам модуля.
    Python повсеместно использует одно и то же обо- значение точкой, придавая ему таким образом характерный
    «Python-овый» вид и не вынуждая нас изучать всё новые и новые способы делать что-либо.


Вот версия, использующая синтаксис from..import

.. code:: python

    # mymodule_demo2.py

    from mymodule import sayhi, __version__

    sayhi()
    print('Версия', __version__)

.. note::

    Обратите внимание, что если в модуле, импортирующем данный модуль, уже было объ- явлено имя __version__,
    возникнет конфликт. Это весьма вероятно, так как объявлять версию любого модуля при помощи этого имени –
    общепринятая практика. Поэтому всегда рекомендуется отдавать предпочтение оператору import, хотя это и
    сделает вашу программу немного длиннее.

Вы могли бы также использовать from mymodule import *

Это импортирует все публичные имена, такие как sayhi, но не импортирует __version__,
потому что оно начинается с двойного подчёркивания

















Библиотеки
==========














Фреймворки
==========














Практика
========