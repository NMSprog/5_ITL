*****************
Модули
*****************

Файлы байткода .pyc
###################

Импорт модуля – относительно дорогостоящее мероприятие, поэтому Python предпри- нимает некоторые трюки
для ускорения этого процесса. Один из способов – создать байт-компилированные файлы (или байткод)
с расширением .pyc, которые являются некой промежуточной формой, в которую Python переводит программу
(помните раздел “Введение” о том, как работает Python?). Такой файл .pyc полезен при импорте модуля в
следующий раз в другую программу – это произойдёт намного быстрее, поскольку зна- чительная часть обработки,
требуемой при импорте модуля, будет уже проделана. Этот байткод также является платформо-независимым.

.. note::
    Обычно файлы .pyc создаются в том же каталоге, где расположены и соот- ветствующие им файлы .py.
    Если Python не может получить доступ для записи файлов в этот каталог, файлы .pyc созданы не будут.


Оператор from ... import ...
############################


Чтобы импортировать переменную argv прямо в программу и не писать всякий раз sys. при обращении к ней,
можно воспользоваться выражением "from sys import argv".
Для импорта всех имён, использующихся в модуле sys, можно выполнить команду "from sys import """*"""".
Это работает для любых модулей.
В общем случае вам следует избегать использования этого оператора и использовать вместо этого оператор
import, чтобы предотвратить конфликты имён и не затруднять чтение программы.

.. code:: python

    from math import *
    n = input("Введите диапазон:- ") p = [2, 3]
    count = 2
    a=5
    while (count < n):
        b=0
        for i in range(2,a):
            if ( i <= sqrt(a)): if (a % i == 0):
                print("a neprost",a)
                b=1
            else:
                pass
        if (b != 1):
            print("a prost",a) p = p + [a]
        count = count + 1
        a=a+2
    print p


Имя модуля – __name__
######################

У каждого модуля есть имя, и команды в модуле могут узнать имя их модуля. Это полез- но, когда нужно знать,
запущен ли модуль как самостоятельная программа или импорти- рован. Как уже упоминалось выше, когда модуль
импортируется впервые, содержащийся в нём код исполняется. Мы можем воспользоваться этим для того, чтобы
заставить мо- дуль вести себя по-разному в зависимости от того, используется ли он сам по себе или
импортируется в другую программа. Этого можно достичь с применением атрибута мо- дуля под названием __name__.

.. code:: python

    if __name__ == '__main__':
        print('Эта программа запущена сама по себе.')
    else:
        print('Меня импортировали в другой модуль.')

**Как это работает:**
    В каждом модуле Python определено его имя – __name__ . Если оно равно '__main__', это означает,
    что модуль запущен самостоятельно пользователем, и мы можем выполнить соответствующие действия.

Создание собственных модулей
############################


Создать собственный модуль очень легко. Да вы всё время делали это! Ведь каждая про- грамма на Python
также является и модулем. Необходимо лишь убедиться, что у неё уста- новлено расширение .py.
Следующий пример объяснит это.


.. code:: python

    # mymodule.py

    def sayhi():
        print('Привет! Это говорит мой модуль.')
    __version__ = '0.1'

Выше приведён простой модуль. Как видно, в нём нет ничего особенного по сравнению с обычной программой
на Python. Далее посмотрим, как использовать этот модуль в дру- гих наших программах.
Помните, что модуль должен находиться либо в том же каталоге, что и программа, в ко- торую мы импортируем
его, либо в одном из каталогов, указанных в sys.path.

.. code:: python

    # mymodule_demo.py

    import mymodule

    mymodule.sayhi()
    print ('Версия', mymodule.__version__)


.. note::

    Обратите внимание, что мы используем всё то же обозначение точкой для до- ступа к элементам модуля.
    Python повсеместно использует одно и то же обо- значение точкой, придавая ему таким образом характерный
    «Python-овый» вид и не вынуждая нас изучать всё новые и новые способы делать что-либо.


Вот версия, использующая синтаксис from..import

.. code:: python

    # mymodule_demo2.py

    from mymodule import sayhi, __version__

    sayhi()
    print('Версия', __version__)

.. note::

    Обратите внимание, что если в модуле, импортирующем данный модуль, уже было объ- явлено имя __version__,
    возникнет конфликт. Это весьма вероятно, так как объявлять версию любого модуля при помощи этого имени –
    общепринятая практика. Поэтому всегда рекомендуется отдавать предпочтение оператору import, хотя это и
    сделает вашу программу немного длиннее.

Вы могли бы также использовать from mymodule import *

Это импортирует все публичные имена, такие как sayhi, но не импортирует __version__,
потому что оно начинается с двойного подчёркивания
