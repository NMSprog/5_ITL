******
Python
******

Для установки компилятора языка программирования скачайте инсталятор
соответствующий ващей операционной ссистеме с сайта разработчика Python.org_

Так же установить Python можно испльлзуя консольные утилиты

.. _Python.org: https://www.python.org/downloads/

Установка
=========

Windows
-------

.. code:: console

    choco install python3

Linux: Ubuntu
-------------

.. code:: sh

    sudo apt install python3

Linux: Fedora
-------------

.. code:: sh

    sudo dnf install python3


.. note::
    
    в Linux дистрибутивах установщик пакетов pip (он нам понадобится в будущем)
    необходимо устанавливать дополнительно.

    .. code:: sh

       sudo apt install python3-pip

Введение

Интерактивная среда IDLE
========================

Для вызова интерактивной среды разработчика достаточно в консоли набрать команду:

.. code:: sh

    python3


.. figure:: /_static/images/IDLE.png
    :figwidth: 600px
    :target: /_static/images/IDLE.png



В этой интерактивной среде можно выполнять команды Python и сразу же получать результат выполнение введенной команды.


Редакторы кода и среда разработки IDE
=====================================

Для написания программ на языке Python подойдет любой текстовый редактор, но для более комфортной работы рекомендуется использовать
редакторы кода с подсветкой синтаксиса и отслеживанием ошибок. один из таких редакторов, это VSCODE_

Так же будет полезно использовать полноценную среду разработки IDE, одной из наиболее популярных евляется PyCharm_



Виртуальное окружение (venv)
============================

Для начала работы рекомендуется подготовить виртуальное окружение, оно необходимо для того что бы вслучае использования
дополнительных библиотек они не конфликтовали с другими библиотеками используемыми в других проектах, например: нет
необходимости держать в одном проекте библиотеки фреймворков **Django** и **Flask**

Для того что бы создать виртуальное окружение, в папке с проектом необходимо выполнить команду:

.. code:: sh

    python -m venv venv

незабудьте так же активировать ваше виртуальное окружение выполнив команду:

.. code:: sh

    source venv/bin/activate

это создаст внутри проекта папку venv с компилятором и всеми необходимыми библиотеками используемые по умолчанию.

Так же для того что бы сохранить список используемых в нашем проекте библиотек, нужно создать файл reqirements.txt
его можно создать автоматически выполнив команду:

.. code:: sh

    pip freeze > requirements.txt


Для установки в наше виртуальное окружение необходимых библиотек нужно выполнить команду:

.. code:: sh

    pip install requirements.txt


Попробуйте установить фреймворк **flask** используя менеджер пакетов pip и сохраните список установленных пакетов:

.. code:: sh

    pip install flask
    pip freeze > requirements.txt


Теперь если вы откроете файл **requirements**
вы увидите список наших зависимостей используемые в нашем проекте

.. code:: python

    click==7.1.2
    Flask==1.1.2
    itsdangerous==1.1.0
    Jinja2==2.11.2
    MarkupSafe==1.1.1
    Werkzeug==1.0.1


Первая программа
================


Настало время написать нашу первую программу, создайте файл **Hello_World.py**
со следующим содержимым:

.. literalinclude:: ../../Examples/Hello_World.py
  :language: python


Теперь запустите нашу программу выполгив в консоле команнду:

.. code:: sh

    python Hello_World.py

в консои вы должны увидеть результат нашей программы.

.. note::

    Обратите внимание, что первая строка указывает какой интерпритатор мы будет использовать,
    она необходима если мы хотим запускать нашу команду с интерпритатором по умолчанию, например так:
    
    .. code:: sh

        ./Hello_World.py

    Если этой строки не будет, то мы получим ошибку.

    Вторая строка отвечает за кодировку, тоесть если мы хотим вывести на экран Русские символы, то нам надо
    указать какую кодировку мы будем ипользовать.

.. _PyCharm: https://www.jetbrains.com/pycharm/download/

.. _VSCODE: https://code.visualstudio.com




Типы данных
===========

Переменные в Python:
--------------------
Переменная в языке программирования это название для зарезервированного места в памяти компьютера,
предназначенное для хранения значений. Это означает, что когда вы создаете переменную, вы на самом деле резервируете
определенное место в памяти компьютера.
Основываясь на типе данных переменной, интерпретатор выделяет необходимое количество памяти и решает, что может
находится в зарезервированной области памяти.
Для понимания, можете думать о переменной как о коробке, в которую можно положить любую вещь, но только определенного
размера. Размер в данном примере будет типом переменной. Это не совсем верное определение, но оно дает общее представление о картине в целом.

**Присвоение значения переменной:**

В Python вам не нужно объявлять тип переменной вручную (как, например в С++). Объявление происходит автоматически
(это называется динамическая типизация), когда вы присваиваете значение переменной. Знак равенства ( = ) используется
для присвоения значения переменной.
Операнд по левую сторону от знака равно ( = ) это имя переменной, операнд по правую сторону - значение присвоенное
этой переменной.


**Таблица - Обзор встроенных типов объектов**

+------------------------------+---------+-----------------------------------------------+
| Имя                          | Тип     |  Описание  и пример                           |
+==============================+=========+===============================================+
| Целые Числа                  | int     |  Целые положительные или отрицательные числа  |
|                              |         |  -35, 0, 24, 123467890033373747428            |
+------------------------------+---------+-----------------------------------------------+
| Числа с плавающей точкой     | float   |  Дробные числа 3.14, 2.5, -2.33333, 0.12334   |
+------------------------------+---------+-----------------------------------------------+
|  Строки                      | str     |  Строки "asdf", "Hello world", "123456"       |
+------------------------------+---------+-----------------------------------------------+
| Списки                       | list    |  последовательность элементов                 |
|                              |         |  ["hello", -123, 0.34, "345"]                 |
+------------------------------+---------+-----------------------------------------------+
| Словарь                      | dict    |  Последовательность пар элементов содержаших  |
|                              |         |  ключ-значение (key-value)                    |
|                              |         |  {"Language": "Python", "Version": "3.8"}     |
+------------------------------+---------+-----------------------------------------------+
| Кортеж (Tuple)               | tup     |  Неизменяемая упорядоченная последовательность|
|                              |         |  элементов ("hostname", 1234, -0.45, -32)     |
+------------------------------+---------+-----------------------------------------------+
| Множество                    | set     |  Изменяемая неупоряоченная последовательность |
|                              |         |  элементов {10, "Name", -30, 4.02, 100}       |
+------------------------------+---------+-----------------------------------------------+
| Булевые значения             | bool    |  Тип данных принимающий одно из двух значений |
|                              |         |  true - истина                                |
|                              |         |  false - ложь                                 |
+------------------------------+---------+-----------------------------------------------+


Числа
-----
Числа - Это не изменяемый тип данных.
Числа в Python бывают трёх типов: целые, с плавающей точкой и комплексные.
* Примером целого числа может служить 2.
* Примерами чисел с плавающей точкой (или «плавающих» для краткости) могут быть 3.23 и 52.3E-4. Обозначение E показывает степени числа 10. В данном случае 52.3E-4 означает 52.3 · 10−4.
* Примерыкомплексныхчисел:(-5+4j)и(2.3-4.6j)


.. note::
    Нет отдельного типа ‘long int’ (длинное целое). Целые числа по умолчанию могут быть произвольной длины.

Строки
------
Строки - это неизменяемая упорядоченная последовательность символов, заключенная в кавычки.
Строки применяются для записи текстовой информации (кажем, вашего имени) и произвольных совокупностей байтов
(наподобие содержимого файла изображения). Они являются первым примером того, что в Python называется
последовательностью — позиционно упорядоченной коллекцией других объектов. Для содержащихся элементов
последовательности поддерживают порядок слева направо: элементы сохраняются и извлекаются по своим относительным позициям.
Строго говоря, строки представляют собой последовательности односимвольных строк.

Строки можно суммировать. Тогда они объединяются в одну строку, такая операция называется "Конкатенацией строк":

.. code:: python

    firts_string = "asdfgh"
    second_string = "oiuytr"
    print(firts_string + second_string)


.. note::

    В Python 3 нет ASCII-строк, потому что Unicode является надмножеством (включает в себя) ASCII. Если необходимо получить
    строку строго в кодировке ASCII, используйте str.encode("ascii"). По умолчанию все строки в Unicode.

.. warning::

    Нельзя производить арифметтические операции над строкам и числами
    Например:
    "qwerty" + 3
    Это вызовет ошибку, Но строки можно перемножать
    "#" * 10
    выведет на экран строку
    ##########

Логические и физические строки
==============================

Физическая строка – это то, что вы видите, когда набираете программу. Логическая стро- ка – это то, что Python видит как единое предложение. Python неявно предполагает, что каждой физической строке соответствует логическая строка.
Примером логической строки может служить предложение print('Привет, Мир!') – ес- ли оно на одной строке (как вы видите это в редакторе), то эта строка также соответствует физической строке.
Python неявно стимулирует использование по одному предложению на строку, что об- легчает чтение кода.
Чтобы записать более одной логической строки на одной физической строке, вам придёт- ся явно указать это при помощи точки с запятой (;), которая отмечает конец логической строки/предложения. Например:

.. code:: python

    i=5
    print(i)
    #то же самое, что
    i = 5; print(i);
    #и то же самое может быть записано в виде
    i = 5; print(i);

Однако я настоятельно рекомендую вам придерживаться написания одной логической строки в каждой физической строке. Таким образом вы можете обойтись совсем без точки с запятой. Кстати, я никогда не использовал и даже не встречал точки с запятой в программах на Python.
Можно использовать более одной физической строки для логической строки, но к этому следует прибегать лишь в случае очень длинных строк. Пример написания одной логиче- ской строки, занимающей несколько физических строк, приведён ниже. Это называется явным объединением строк.

.. code:: python

    s = 'Это строка. \
    Это строка продолжается.'
    print(s) #Это строка. Это строка продолжается.

Операции над последовательностями
=================================
Как последовательности, строки поддерживают операции, которые предполагают наличие позиционного порядка среди
элементов. Например, если мы имеем четырех­ символьную строку, записанную в кавычках (обычно одинарных), то можем
проверить ее длину с помощью встроенной функции **len()** и извлечь ее компоненты посредством выражений индексации.

.. literalinclude:: ../../Examples/String.py
  :language: python

Нумерация всех символов в строке идет с нуля. Но, если нужно обратиться к какому-то по счету символу, начиная с конца,
то можно указывать отрицательные значения (на этот раз с единицы).

.. code:: python

    simple_string = "StringBody"
    simple_string[1]
    # t

    simple_string[-1]
    # y

Кроме обращения к конкретному символу, можно делать срезы строк, указав диапазон номеров (срез выполняется по второе число, не включая его):

.. code:: python

    example_string = "Lorem Ipsum is simply dummy text of the printing and typesetting"
    example_string[0:9]
    # 'Lorem Ips'

    example_string[10:22]
    # 'm is simply '

    # Если не указывается второе число, то срез будет до конца строки:
    example_string[-3:]
    # 'ing'

Также в срезе можно указывать шаг:

.. code:: python

    # Так можно получить нечетные числа
    a = '0123456789'
    a[1::2]
    # '13579'

    # А таким образом можно получить все четные числа строки a:
    a[::2]
    # '02468'

    # Срезы также можно использовать для получения строки в обратном порядке:
    a[::-1]
    # '9876543210'

Методы для работы со строками
=============================
**Методы upper, lower, swapcase, capitalize**

Методы upper(), lower(), swapcase(), capitalize() выполняют преобразование регистра строки:

.. code:: python

    string1 = 'FastEthernet'

    string1.upper()
    #'FASTETHERNET'

    string1.lower()
    #'fastethernet'

    string1.swapcase()
    #'fASTeTHERNET'

    string2 = 'tunnel 0'

    string2.capitalize()
    #'Tunnel 0'

    #Очень важно обращать внимание на то, что часто методы возвращают преобразованную строку. И, значит, надо не забыть присвоить ее какой-то переменной (можно той же).
    string1 = string1.upper()
    print(string1)
    #FASTETHERNET


**Метод count**

Метод count() используется для подсчета того, сколько раз символ или подстрока встречаются в строке:

.. code:: python

    string1 = 'Hello, hello, hello, hello'
    string1.count('hello') # 3
    string1.count('ello') # 4
    string1.count('l') # 8

**Метод find**

Методу find() можно передать подстроку или символ, и он покажет, на какой позиции находится первый символ подстроки (для первого совпадения):

.. code:: python

    string1 = 'interface FastEthernet0/1'
    string1.find('Fast') # 10
    string1[string1.find('Fast')::] # 'FastEthernet0/1'

**Методы startswith, endswith**

Проверка на то, начинается или заканчивается ли строка на определенные символы (методы startswith(), endswith()):

.. code:: python

    string1 = 'FastEthernet0/1'
    string1.startswith('Fast') # True
    string1.startswith('fast') # False
    string1.endswith('0/1') # True
    string1.endswith('0/2') # False

**Метод replace**

Замена последовательности символов в строке на другую последовательность (метод replace()):

.. code:: python

    string1 = 'FastEthernet0/1'
    string1.replace('Fast', 'Gigabit') # 'GigabitEthernet0/1'

**Метод strip**

Часто при обработке файла файл открывается построчно. Но в конце каждой строки, как правило, есть какие-то спецсимволы (а могут быть и в начале). Например, перевод строки.

Для того, чтобы избавиться от них, очень удобно использовать метод strip():

.. code:: python

    string1 = '\n\tinterface FastEthernet0/1\n'
    print(string1)
    #
    #interface FastEthernet0/1
    #

    string1.strip()
    #'interface FastEthernet0/1'


.. note::
    По умолчанию метод strip() убирает пробельные символы. В этот набор символов входят: \t\n\r\f\v

    Методу strip можно передать как аргумент любые символы. Тогда в начале и в конце строки будут удалены все символы, которые были указаны в строке:

    Метод strip() убирает спецсимволы и в начале, и в конце строки. Если необходимо убрать символы только слева или только справа, можно использовать, соответственно, методы lstrip() и rstrip().

**Метод split**

Метод split() разбивает строку на части, используя как разделитель какой-то символ (или символы) и возвращает список строк:

.. code:: python

    string1 = 'switchport trunk allowed vlan 10,20,30,100-200'
    commands = string1.split()
    print(commands) # ['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']

    #По умолчанию в качестве разделителя используются пробельные символы (пробелы, табы, перевод строки), но в скобках можно указать любой разделитель:
    vlans = commands[-1].split(',')
    print(vlans) #['10', '20', '30', '100-200']

**Метод join**

Метод join() позволяет объеденить список, кортеж или словарь в строку разделяя ее елементы другой строкой.

.. code:: python

    myTuple = ("John", "Peter", "Vicky")
    x = "-".join(myTuple)
    print(x) #John-Peter-Vicky

**Метод format**

Метод format() позволяет подставлять в отмеченные в строке области символами "{}" значени из списка аргументов

например:

.. code:: python

    price = 49
    txt = "The price is {} dollars"
    print(txt.format(price))

Так же можно указать тип подставлемых значений:


.. literalinclude:: ../../Examples/format.py
  :language: python

другие примеры форматированого вывода можно ныйти по следующим ссылкам pyformat.info_ w3schools.com_

.. _pyformat.info: https://pyformat.info

.. _w3schools.com: https://www.w3schools.com/python/python_string_formatting.asp


Пример программы
================

**Подсчет слов**

.. literalinclude:: ../../Examples/words_counter.py
  :language: python


Списки
------
Списки – это изменяемые упорядоченные последовательности произвольных объектов. Списки создаются посредством заключения элементов списка в квадратные скобки

.. code-block:: python

    names = [ "Dave", "Mark", "Ann", "Phil" ]

Элементы списка индексируются целыми числами, первый элемент списка имеет индекс, равный нулю. Для доступа к отдельным элементам списка используется оператор индексирования

.. code-block:: python

    a = names[2] # Вернет третий элемент списка, "Ann"
    names[0] = "Jeff" # Запишет имя "Jeff" в первый элемент списка

    С помощью оператора среза можно извлекать и изменять целые фрагменты списков:

.. code-block:: python

    b = names[0:2]     # Вернет ["Jeff", "Mark"]
    c = names[2:]      # Вернет ["Thomas", "Ann", "Phil", "Paula"]
    names[1] = "Jeff"  # Во второй элемент запишет имя "Jeff"
    names[0:2] = ["Dave", "Mark", "Jeff"]  # Заменит первые два элемента списком справа.


Списки могут содержать объекты любого типа, числа, строки, другие списки

.. code-block:: python

    a = [1,"Dave",3.14, ["Mark", 7, 9, [100,101]], 10]

Списки так же как и строки можно конкатинировать между собоой

.. code-block:: python

    [1,2,3] + [4,5] # Создаст список [1,2,3,4,5]


Методы для работы со списками
=============================

**List()**

создаст пустой список, либо преобразует аргументы в список

.. code-block:: python

    l = list('1234567890')
    print(l) # [1,2,3,4,5,6,7,8,9,0]

**join()**

собирает список строк в одну строку с разделителем, который указан перед join:

.. code-block:: python

    a = ['10', '20', '30']
    print(','.join(a)) # 10,20,30

.. note::

    Метод join на самом деле относится к строкам, но так как значение ему надо передавать как список, он рассматривается тут.

**append()**

добавляет в конец списка указанный элемент:

.. code-block:: python

    a = ['10', '20', '30', '100-200']
    a.append('300')
    print(a) # ['10', '20', '30', '100-200', '300']

**extend()**

Если нужно объединить два списка, то можно использовать два способа: метод extend() и операцию сложения.

У этих способов есть важное отличие - extend меняет список, к которому применен метод, а суммирование возвращает новый список, который состоит из двух.

.. code-block:: python

    a = ['10', '20', '30', '100-200']
    b = ['300', '400', '500']
    a.extend(b)
    print(a) # ['10', '20', '30', '100-200', '300', '400', '500']

**pop()**

удаляет элемент, который соответствует указанному номеру. Но, что важно, при этом метод возвращает этот элемент:

.. code-block:: python

    a = ['10', '20', '30', '100-200']
    a.pop(-1) # '100-200'
    print(a) #['10', '20', '30']

.. note::

    Без указания номера удаляется последний элемент списка.


**remove()**

удаляет указанный элемент и не возвращает удаленный элемент:

.. code-block:: python

    a = ['10', '20', '30', '100-200']
    a.remove('20')
    print(a) # ['10', '30', '100-200']

.. note::

    В методе remove надо указывать сам элемент, который надо удалить, а не его номер в списке. Если указать номер элемента, возникнет ошибка:

**insert()**

позволяет вставить элемент на определенное место в списке:

.. code-block:: python

    a = ['10', '20', '30', '100-200']
    a.insert(1, '15')
    print(a) # ['10', '15', '20', '30', '100-200']


**sort()**

сортирует список на месте:

.. code:: python

    a = [1, 50, 10, 15]
    a.sort()
    print(a) # [1, 10, 15, 50]




Словари
-------

Словари Python — нечто совершенно иное; они вообще не являются последовательностями и взамен известны как отображения.
Отображения также представляют собой коллекции других объектов, но они хранят объекты по ключам, а не по относительным позициям.
В действительности отображения не поддерживают какой-либо надежный порядок слева направо; они просто отображают ключи
на связанные значения. Словари — единственный тип отображения в наборе основных объектов Python — являются изменяемыми,’
как и списки, их можно модифицировать на месте и они способны увеличиваться и уменьшаться по требованию. Наконец, подобно
спискам словари — это гибкий инструмент для представления коллекций, но их мнемонические ключи лучше подходят, когда
элементы коллекции именованы или помечены, скажем, как поля в записи базы данных.

Словари - это изменяемый упорядоченный тип данных:

* данные в словаре - это пары ключ: значение
* доступ к значениям осуществляется по ключу, а не по номеру, как в списках
* данные в словаре упорядочены по порядку добавления элементов
* так как словари изменяемы, то элементы словаря можно менять, добавлять, удалять
* ключ должен быть объектом неизменяемого типа: число, строка, кортеж
* значение может быть данными любого типа

для удобства словарь можно записать так:

.. code:: python

    london = {
    'id': 1,
    'name':'London',
    'it_vlan':320,
    'user_vlan':1010,
    'mngmt_vlan':99,
    'to_name': None,
    'to_id': None,
    'port':'G1/0/11'
    }

Для того, чтобы получить значение из словаря, надо обратиться по ключу, таким же образом, как это было в списках, только вместо номера будет использоваться ключ:

.. code:: python

    london = {'name': 'London1', 'location': 'London Str'}
    print(london['name'], london['location'])
    #'London1' 'London Str'

При написании в виде литералов словари указываются в фигурных скобках и состо­ ят из ряда пар “ключ: значение”.
Словари удобны всегда, когда нам необходимо ассо­ циировать набор значений с ключами — например, для описания
свойств чего-нибудь. Рассмотрим следующий словарь их трех элементов (с ключами ’ food ’, ’ quantity ’ и
’ color ’, возможно представляющих детали позиции гипотетического меню):

.. code:: python

    D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}

Мы можем индексировать этот словарь по ключу, чтобы извлекать и изменять зна­ чения, связанные с ключами.
Операция индексации словаря имеет такой же синтак­ сис, как для последовательностей, но элементом в
квадратных скобках будет ключ, а не относительная позиция:

.. code:: python

    D['food'] # Извлечь значение, связанное с ключом 'food' 'Spam'
    D['quantity'] += 1 # Добавить 1 к значению, связанному с ключом 'quantity'
    print(D)
    #{'color': 'pink', 'food': 'Spam', 'quantity': 5}

Хотя форма литерала в фигурных скобках встречается, пожалуй, чаще приходится видеть словари, построенные другими
способами (все данные программы редко из­ вестны до ее запуска). Скажем, следующий код начинает с пустого словаря и
заполняет его по одному ключу за раз. В отличие от присваивания элементу в списке, находящемуся вне установленных
границ, которое запрещено, присваивание новому ключу словаря приводит к созданию этого ключа:

.. code:: python

    D = {}
    D['name'] = 'Bob'
    D['job'] = 'dev'
    D['age'] =40
    print (D)
    #{'*:age 40, 'job': 'dev', 'name': 'Bob'}
    print(D['name'])
    #Bob

В словаре в качестве значения можно использовать словарь:

.. code:: python

    london_co = {
        'r1': {
            'hostname': 'london_r1',
            'location': '21 New Globe Walk',
            'vendor': 'Cisco',
            'model': '4451',
            'ios': '15.4',
            'ip': '10.255.0.1'
        },
        'r2': {
            'hostname': 'london_r2',
            'location': '21 New Globe Walk',
            'vendor': 'Cisco',
            'model': '4451',
            'ios': '15.4',
            'ip': '10.255.0.2'
        },
        'sw1': {
            'hostname': 'london_sw1',
            'location': '21 New Globe Walk',
            'vendor': 'Cisco',
            'model': '3850',
            'ios': '3.6.XE',
            'ip': '10.255.0.101'
        }
    }

Получить значения из вложенного словаря можно так:

.. code:: python

    london_co['r1']['ios'] #'15.4'
    london_co['r1']['model'] #'4451'
    london_co['sw1']['ip'] #'10.255.0.101'

Методы для работы со словарями
------------------------------

**clear()**

- позволяет очистить словарь:

.. code::python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'model': '4451', 'ios': '15.4'}
    london.clear()
    print(london) #{}

**copy()**

- создает полную копию словаря

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    london2 = london.copy()
    id(london) #25524512
    id(london2) #25563296
    london['vendor'] = 'Juniper'
    london2['vendor'] #'Cisco'

.. note::

    Если указать, что один словарь равен другому,
    то london2 будет ссылкой на словарь. И при изменениях словаря london меняется и словарь london2, так как это ссылки на один и тот же объект.


**get()**

- запрашивает ключ, и если его нет, вместо ошибки возвращает None.

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    print(london.get('ios')) #None

    #Метод get() позволяет также указывать другое значение вместо None
    print(london.get('ios', 'Ooops')) #Ooops

**setdefault()**

 - ищет ключ, и если его нет, вместо ошибки создает ключ со значением None, если ключ есть, setdefault возвращает значение, которое ему соответствует:

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    ios = london.setdefault('ios')
    print(ios) #None
    london #{'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': None}
    london.setdefault('name') #'London1'

    #Второй аргумент позволяет указать, какое значение должно соответствовать ключу
    model = london.setdefault('model', 'Cisco3580')
    print(model) #Cisco3580
    london
    {'name': 'London1',
     'location': 'London Str',
     'vendor': 'Cisco',
     'ios': None,
     'model': 'Cisco3580'}

    # Метод setdefault заменяет такую конструкцию:
    if key in london:
         value = london[key]
    else:
         london[key] = 'somevalue'
         value = london[key]


**keys(), values(), items()**

Все три метода возвращают специальные объекты view, которые отображают ключи, значения и пары ключ-значение словаря соответственно.

Очень важная особенность view заключается в том, что они меняются вместе с изменением словаря. И фактически они лишь дают способ посмотреть на соответствующие объекты, но не создают их копию.

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    keys = london.keys()
    print(keys)
    #dict_keys(['name', 'location', 'vendor'])

    #Сейчас переменной keys соответствует view dict_keys, в котором три ключа: name, location и vendor.
    #Но, если мы добавим в словарь еще одну пару ключ-значение, объект keys тоже поменяется:
    london['ip'] = '10.1.1.1'
    keys
    #dict_keys(['name', 'location', 'vendor', 'ip'])

    #Если нужно получить обычный список ключей, который не будет меняться с изменениями словаря, достаточно конвертировать view в список:
    list_keys = list(london.keys())
    list_keys
    #['name', 'location', 'vendor', 'ip']

**del()**

Удаляет ключ и значение

.. code:: python

    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    del london['name']
    london
    #{'location': 'London Str', 'vendor': 'Cisco'}

**update()**

Позволяет добавлять в словарь содержимое другого словаря:

.. code:: python

    r1 = {'name': 'London1', 'location': 'London Str'}
    r1.update({'vendor': 'Cisco', 'ios':'15.2'})
    r1
    # {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': '15.2'}

    #Аналогичным образом можно обновить значения:
    r1.update({'name': 'london-r1', 'ios':'15.4'})
    r1
    '''
    {'name': 'london-r1',
     'location': 'London Str',
     'vendor': 'Cisco',
     'ios': '15.4'}
    '''

Кортежи
-------

Объект кортежа примерно похож на список, который нельзя изменять — кортежи являются последовательностями
подобно спискам, но они неизменяемые подобно строка­ ми. Функционально они используются для представления
фиксированных коллекций элементов: скажем, компонентов специфической даты в календаре. Синтаксически они
записываются в круглых, а не квадратных скобках и поддерживают произвольные типы, произвольное вложение и
обычные операции над последовательностями:

.. code:: python

    T = (1, 2, 3, 4) # Кортеж из 4 элементов
    len(Т)           # Длина 4
    Т + (5, б)       # Конкатенация (1, 2, 3, 4, 5, 6)
    Т[О]             # Индексация, нарезание и т.д.

.. note::

    Главное отличие кортежей заключается в том, что после создания их нельзя из­ менять, т.е. они
    являются неизменяемыми последовательностями (одноэлементные кортежи вроде приведенного ниже требуют
    хвостовой запятой):
    tuple2 = ('password',)


Итак, зачем нам тип, который похож на список, но поддерживает меньше операций? Откровенно говоря,
на практике кортежи применяются в целом не так часто, как списки, но весь смысл в их неизменяемости.
Если вы передаете коллекцию объектов внутри своей программы в виде списка, тогда он может быть
модифицирован где угодно; если вы используете кортеж, то изменить его не удастся. То есть кортежи
обеспечивают своего рода ограничение целостности, что удобно в программах, крупнее тех, которые мы будем
писать здесь. Позже в книге мы еще обсудим кортежи, включая расширение, которое построено поверх них и
называется именованными кортежами.

Множество
---------

Множество - это изменяемый неупорядоченный тип данных. В множестве всегда содержатся только уникальные элементы.

Множество в Python - это последовательность элементов, которые разделены между собой запятой и заключены в фигурные скобки.

С помощью множества можно легко убрать повторяющиеся элементы:

.. code:: python

    cities = ['Санкт-Петербург', 'Хабаровск', 'Казань', 'Санкт-Петербург', 'Казань']
    un_cities = set(cities)
    for city in un_cities:
        print("Один мой друг живёт в городе " + city)

    '''
    Один мой друг живёт в городе Хабаровск
    Один мой друг живёт в городе Санкт-Петербург
    Один мой друг живёт в городе Казань
    '''

Множества полезны тем, что с ними можно делать различные операции и находить объединение множеств, пересечение и так далее.

Объединение множеств можно получить с помощью метода union() или оператора "|":

.. code:: python

    vlans1 = {10,20,30,50,100}
    vlans2 = {100,101,102,102,200}
    vlans1.union(vlans2) #{10, 20, 30, 50, 100, 101, 102, 200}
    vlans1 | vlans2 #{10, 20, 30, 50, 100, 101, 102, 200}

    #Пересечение множеств можно получить с помощью метода intersection() или оператора &
    vlans1 = {10,20,30,50,100}
    vlans2 = {100,101,102,102,200}
    vlans1.intersection(vlans2) #{100}
    vlans1 & vlans2 #{100}

.. warning::
    Нельзя создать пустое множество с помощью литерала (так как в таком случае это будет не множество, а словарь):
    set1 = {}
    type(set1) #dict

    Но пустое множество можно создать таким образом
    set2 = set()
    type(set2) #set


Методы для работы с множествами
-------------------------------

**add()**

добавляет элемент во множество:

.. code:: python

    set1 = {10,20,30,40}
    set1.add(50)
    set1 #{10, 20, 30, 40, 50}

**discard()**

позволяет удалять элементы, не выдавая ошибку, если элемента в множестве нет

.. code:: python

    set1 #{10, 20, 30, 40, 50}
    set1.discard(55)
    set1 #{10, 20, 30, 40, 50}
    set1.discard(50)
    set1 #{10, 20, 30, 40}

**clear()**

очищает множество

.. code:: python

    set1 = {10,20,30,40}
    set1.clear()
    set1 #set()

Булевы значения
---------------

Булевы значения в Python это две константы True и False.

В Python истинными и ложными значениями считаются не только True и False.

* истинное значение:

 * любое ненулевое число
 * любая непустая строка
 * любой непустой объект

* ложное значение:

 * 0
 * None
 * пустая строка
 * пустой объект 

Остальные истинные и ложные значения, как правило, логически следуют из условия.

Для проверки булевого значения объекта, можно воспользоваться bool:

.. code:: python

    items = [1, 2, 3]
    empty_list = []
    bool(empty_list) #False
    bool(items) #True
    bool(0) #False
    bool(1) #True

Преобразование типов
--------------------

В Python есть несколько полезных встроенных функций, которые позволяют преобразовать данные из одного типа в другой.

**int()**

преобразует строку в int:

.. code:: python

    int("10") #10
    int("11111111", 2) #255  С помощью функции int можно преобразовать и число в двоичной записи в десятичную (двоичная запись должна быть в виде строки)

**bin()**

Преобразовать десятичное число в двоичный формат можно с помощью bin():

.. code:: python

    bin(10) #'0b1010'
    bin(255) #'0b11111111'

**hex()**

Аналогичная функция есть и для преобразования в шестнадцатеричный формат:

.. code:: python

    hex(10) #'0xa'
    hex(255) #'0xff'

**list()**

Функция list() преобразует аргумент в список:

.. code:: python

    list("string") #['s', 't', 'r', 'i', 'n', 'g']
    list({1,2,3})  #[1, 2, 3]
    list((1,2,3,4)) #[1, 2, 3, 4

**set()**

Функция set() преобразует аргумент в множество:

.. code:: python

    set([1,2,3,3,4,4,4,4]) #{1, 2, 3, 4}
    set((1,2,3,3,4,4,4,4)) #{1, 2, 3, 4}
    set("string string") #{' ', 'g', 'i', 'n', 'r', 's', 't'}

**tuple()**

Функция tuple() преобразует аргумент в кортеж:

.. code:: python

    tuple([1,2,3,4]) #(1, 2, 3, 4)
    tuple({1,2,3,4}) #(1, 2, 3, 4)
    tuple("string")  #('s', 't', 'r', 'i', 'n', 'g')

**str()**

Функция str() преобразует аргумент в строку:

.. code:: python

    str(10) #'10'

Проверка типов
--------------

**isdigit()**

Проверяет, сосоит ли строка из одних только цифр

.. code:: python

    "a".isdigit() #False
    "a10".isdigit() #False
    "10".isdigit() #True

**isalpha()**

Проверяет, состоит ли строка из одних букв:

.. code:: python

    "a".isalpha() #True
    "a100".isalpha() #False
    "a--  ".isalpha() #False
    "a ".isalpha() #False

**isalnum()**

позволяет проверить, состоит ли строка из букв или цифр:

.. code:: python

    "a".isalnum() #True
    "a10".isalnum() #True

**type()**

Иногда, в зависимости от результата, библиотека или функция может выводить разные типы объектов. Например, если объект один, возвращается строка, если несколько, то возвращается кортеж.

Нам же надо построить ход программы по-разному, в зависимости от того, была ли возвращена строка или кортеж.

В этом может помочь функция type():

.. code:: python

    type("string") #str
    type("string") is str #True

    #Аналогично с кортежем (и другими типами данных):
    type((1,2,3)) #tuple
    type((1,2,3)) is tuple #True
    type((1,2,3)) is list #False

Файлы
-----

Объекты файлов являются главным интерфейсом к внешним файлам на компью­ тере.
Они могут применяться для чтения и записи текстовых заметок, аудиоклипов,
документов Excel, сохраненных сообщений электронной почты и всего того, что вы в итоге
сохранили на своем компьютере. Файлы относятся к основным типам, но они кое в чем своеобразны — специфический
литеральный синтаксис для их создания от­ сутствует, Взамен, чтобы создать объект файла,
необходимо вызвать встроенную фун­ кцию open, передав ей в виде строк имя внешнего файла и необязательный
режим обработки.

Например, для создания выходного текстового файла понадобится передать его имя и строку режима обработки ’ w ’, чтобы записывать данные:

.. code:: python

    f = open('data.txt' , 'w') # Создать новый файл в режиме записи ('w')
    f.write('Hello\n') # Записать в него строки символов
    f.write ('world\n') # Возвратить количество записанных элементов
    f.close()   # Закрыть для сбрасывания буферов вывода на диск

Код создает файл в текущем каталоге и записывает в него текст (имя файла мо­ жет содержать полный путь к каталогу,
если нужно получить доступ к файлу где-то в другом месте на компьютере). Чтобы прочитать то, что было записано,
необходимо повторно открыть файл в режиме обработки ’ г ’ для чтения текстового ввода (он вы­ бирается по умолчанию,
если в вызове строка режима не указана). Затем следует про­ читать содержимое файла в строку и отобразить ее.
В сценарии содержимое файла всегда будет строкой независимо от типа находящихся в нем данных:

.. code:: python

    f = open('data.txt')    # 'г' (чтение) - стандартный режим обработки
    text = f.read()         # Прочитать все содержимое файла в строку
    text                    #'Hello\nworld\n'
    print(text)             # print интерпретирует управляющие символы
    #Hello
    #world
    text.split()            # Содержимое файла - всегда строка
    #['Hello', 'world']

.. note::

    Обратите внимание, что для того что бы прочесь все строки из файла, нам нужно обернуть функцию чтения в цикл
    for line in open(’data.txt’): print(line)

    так же не забывайте закрывать файл после операции чтения или записи
    f.close

.. note::

    Ранее в примере с подсчетом слов мы использовали друую констукцию

        with open(filename, encoding="utf8") as file: #эта строка открывает файл
            text = file.read()  #читаем содержимое файла и записываем все в переменную text

            text = text.replace("\n", " ") #преобразуем наш текст в одну длинную строку заменив символ перевода строки на пробел

            text = text.replace(",", "").replace(".", "").replace("?", "").replace("!", "") #а так же уберем все запетые, пробелы, и прочие знаки пунктуации

            text = text.lower()  #перведем все слова в строчные, тоесть если было "Начало изучения Языка Программирования", то будет "начало изучения языка программирования"

            words = text.split() #создадим список слов ("списки", "выгледят", "вот","так")

            words.sort()

    Такой подход позволяет не закрывать файл в ручную.
